{"/home/travis/build/npmtest/node-npmtest-minimongo/test.js":"/* istanbul instrument in package npmtest_minimongo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-minimongo/lib.npmtest_minimongo.js":"/* istanbul instrument in package npmtest_minimongo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_minimongo = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_minimongo = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-minimongo/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-minimongo && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_minimongo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_minimongo\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_minimongo.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_minimongo.rollup.js'] =\n            local.assetsDict['/assets.npmtest_minimongo.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_minimongo.__dirname +\n                    '/lib.npmtest_minimongo.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-minimongo/node_modules/minimongo/index.js":"exports.MemoryDb = require('./lib/MemoryDb');\nexports.LocalStorageDb = require('./lib/LocalStorageDb');\nexports.IndexedDb = require('./lib/IndexedDb');\nexports.WebSQLDb = require('./lib/WebSQLDb');\nexports.RemoteDb = require('./lib/RemoteDb');\nexports.HybridDb = require('./lib/HybridDb');\nexports.ReplicatingDb = require('./lib/ReplicatingDb');\nexports.utils = require('./lib/utils');\n","/home/travis/build/npmtest/node-npmtest-minimongo/node_modules/minimongo/lib/MemoryDb.js":"var Collection, MemoryDb, async, compileSort, processFind, utils, _;\n\n_ = require('lodash');\n\nasync = require('async');\n\nutils = require('./utils');\n\nprocessFind = require('./utils').processFind;\n\ncompileSort = require('./selector').compileSort;\n\nmodule.exports = MemoryDb = (function() {\n  function MemoryDb(options, success) {\n    this.collections = {};\n    if (success) {\n      success(this);\n    }\n  }\n\n  MemoryDb.prototype.addCollection = function(name, success, error) {\n    var collection;\n    collection = new Collection(name);\n    this[name] = collection;\n    this.collections[name] = collection;\n    if (success != null) {\n      return success();\n    }\n  };\n\n  MemoryDb.prototype.removeCollection = function(name, success, error) {\n    delete this[name];\n    delete this.collections[name];\n    if (success != null) {\n      return success();\n    }\n  };\n\n  return MemoryDb;\n\n})();\n\nCollection = (function() {\n  function Collection(name) {\n    this.name = name;\n    this.items = {};\n    this.upserts = {};\n    this.removes = {};\n  }\n\n  Collection.prototype.find = function(selector, options) {\n    return {\n      fetch: (function(_this) {\n        return function(success, error) {\n          return _this._findFetch(selector, options, success, error);\n        };\n      })(this)\n    };\n  };\n\n  Collection.prototype.findOne = function(selector, options, success, error) {\n    var _ref;\n    if (_.isFunction(options)) {\n      _ref = [{}, options, success], options = _ref[0], success = _ref[1], error = _ref[2];\n    }\n    return this.find(selector, options).fetch(function(results) {\n      if (success != null) {\n        return success(results.length > 0 ? results[0] : null);\n      }\n    }, error);\n  };\n\n  Collection.prototype._findFetch = function(selector, options, success, error) {\n    return setTimeout((function(_this) {\n      return function() {\n        var results;\n        results = processFind(_.values(_this.items), selector, options);\n        if (success != null) {\n          return success(results);\n        }\n      };\n    })(this), 0);\n  };\n\n  Collection.prototype.upsert = function(docs, bases, success, error) {\n    var item, items, _i, _len, _ref;\n    _ref = utils.regularizeUpsert(docs, bases, success, error), items = _ref[0], success = _ref[1], error = _ref[2];\n    items = JSON.parse(JSON.stringify(items));\n    for (_i = 0, _len = items.length; _i < _len; _i++) {\n      item = items[_i];\n      if (item.base === void 0) {\n        if (this.upserts[item.doc._id]) {\n          item.base = this.upserts[item.doc._id].base;\n        } else {\n          item.base = this.items[item.doc._id] || null;\n        }\n      }\n      this.items[item.doc._id] = item.doc;\n      this.upserts[item.doc._id] = item;\n    }\n    if (success) {\n      return success(docs);\n    }\n  };\n\n  Collection.prototype.remove = function(id, success, error) {\n    if (_.isObject(id)) {\n      this.find(id).fetch((function(_this) {\n        return function(rows) {\n          return async.each(rows, function(row, cb) {\n            return _this.remove(row._id, (function() {\n              return cb();\n            }), cb);\n          }, function() {\n            return success();\n          });\n        };\n      })(this), error);\n      return;\n    }\n    if (_.has(this.items, id)) {\n      this.removes[id] = this.items[id];\n      delete this.items[id];\n      delete this.upserts[id];\n    } else {\n      this.removes[id] = {\n        _id: id\n      };\n    }\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype.cache = function(docs, selector, options, success, error) {\n    var doc, docsMap, sort, _i, _len;\n    for (_i = 0, _len = docs.length; _i < _len; _i++) {\n      doc = docs[_i];\n      this.cacheOne(doc);\n    }\n    docsMap = _.object(_.pluck(docs, \"_id\"), docs);\n    if (options.sort) {\n      sort = compileSort(options.sort);\n    }\n    return this.find(selector, options).fetch((function(_this) {\n      return function(results) {\n        var result, _j, _len1;\n        for (_j = 0, _len1 = results.length; _j < _len1; _j++) {\n          result = results[_j];\n          if (!docsMap[result._id] && !_.has(_this.upserts, result._id)) {\n            if (options.sort && options.limit && docs.length === options.limit) {\n              if (sort(result, _.last(docs)) >= 0) {\n                continue;\n              }\n            }\n            delete _this.items[result._id];\n          }\n        }\n        if (success != null) {\n          return success();\n        }\n      };\n    })(this), error);\n  };\n\n  Collection.prototype.pendingUpserts = function(success) {\n    return success(_.values(this.upserts));\n  };\n\n  Collection.prototype.pendingRemoves = function(success) {\n    return success(_.pluck(this.removes, \"_id\"));\n  };\n\n  Collection.prototype.resolveUpserts = function(upserts, success) {\n    var id, upsert, _i, _len;\n    for (_i = 0, _len = upserts.length; _i < _len; _i++) {\n      upsert = upserts[_i];\n      id = upsert.doc._id;\n      if (this.upserts[id]) {\n        if (_.isEqual(upsert.doc, this.upserts[id].doc)) {\n          delete this.upserts[id];\n        } else {\n          this.upserts[id].base = upsert.doc;\n        }\n      }\n    }\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype.resolveRemove = function(id, success) {\n    delete this.removes[id];\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype.seed = function(docs, success) {\n    var doc, _i, _len;\n    if (!_.isArray(docs)) {\n      docs = [docs];\n    }\n    for (_i = 0, _len = docs.length; _i < _len; _i++) {\n      doc = docs[_i];\n      if (!_.has(this.items, doc._id) && !_.has(this.removes, doc._id)) {\n        this.items[doc._id] = doc;\n      }\n    }\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype.cacheOne = function(doc, success) {\n    var existing;\n    if (!_.has(this.upserts, doc._id) && !_.has(this.removes, doc._id)) {\n      existing = this.items[doc._id];\n      if (!existing || !doc._rev || !existing._rev || doc._rev >= existing._rev) {\n        this.items[doc._id] = doc;\n      }\n    }\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype.uncache = function(selector, success, error) {\n    var compiledSelector, items;\n    compiledSelector = utils.compileDocumentSelector(selector);\n    items = _.filter(_.values(this.items), (function(_this) {\n      return function(item) {\n        return (_this.upserts[item._id] != null) || !compiledSelector(item);\n      };\n    })(this));\n    this.items = _.object(_.pluck(items, \"_id\"), items);\n    if (success != null) {\n      return success();\n    }\n  };\n\n  return Collection;\n\n})();\n","/home/travis/build/npmtest/node-npmtest-minimongo/node_modules/minimongo/lib/utils.js":"var async, bowser, compileDocumentSelector, compileSort, deg2rad, getDistanceFromLatLngInM, isLocalStorageSupported, pointInPolygon, processGeoIntersectsOperator, processNearOperator, _;\n\n_ = require('lodash');\n\nasync = require('async');\n\nbowser = require('bowser');\n\ncompileDocumentSelector = require('./selector').compileDocumentSelector;\n\ncompileSort = require('./selector').compileSort;\n\nisLocalStorageSupported = function() {\n  var e;\n  if (!window.localStorage) {\n    return false;\n  }\n  try {\n    window.localStorage.setItem(\"test\", \"test\");\n    window.localStorage.removeItem(\"test\");\n    return true;\n  } catch (_error) {\n    e = _error;\n    return false;\n  }\n};\n\nexports.compileDocumentSelector = compileDocumentSelector;\n\nexports.autoselectLocalDb = function(options, success, error) {\n  var IndexedDb, LocalStorageDb, MemoryDb, WebSQLDb, browser;\n  IndexedDb = require('./IndexedDb');\n  WebSQLDb = require('./WebSQLDb');\n  LocalStorageDb = require('./LocalStorageDb');\n  MemoryDb = require('./MemoryDb');\n  browser = bowser.browser;\n  if (!isLocalStorageSupported()) {\n    return new MemoryDb(options, success);\n  }\n  if (window.cordova) {\n    console.log(\"Selecting WebSQLDb for Cordova\");\n    return new WebSQLDb(options, success, error);\n  }\n  if (browser.android || browser.ios || browser.chrome || browser.safari || browser.opera || browser.blackberry) {\n    console.log(\"Selecting WebSQLDb for browser\");\n    return new WebSQLDb(options, success, (function(_this) {\n      return function(err) {\n        console.log(\"Failed to create WebSQLDb: \" + (err ? err.message : void 0));\n        return new IndexedDb(options, success, function(err) {\n          console.log(\"Failed to create IndexedDb: \" + (err ? err.message : void 0));\n          return new MemoryDb(options, success);\n        });\n      };\n    })(this));\n  }\n  if (browser.firefox && browser.version >= 16) {\n    console.log(\"Selecting IndexedDb for browser\");\n    return new IndexedDb(options, success, (function(_this) {\n      return function(err) {\n        console.log(\"Failed to create IndexedDb: \" + (err ? err.message : void 0));\n        return new MemoryDb(options, success);\n      };\n    })(this));\n  }\n  console.log(\"Selecting LocalStorageDb for fallback\");\n  return new LocalStorageDb(options, success, error);\n};\n\nexports.migrateLocalDb = function(fromDb, toDb, success, error) {\n  var HybridDb, col, hybridDb, name, _ref;\n  HybridDb = require('./HybridDb');\n  hybridDb = new HybridDb(fromDb, toDb);\n  _ref = fromDb.collections;\n  for (name in _ref) {\n    col = _ref[name];\n    if (toDb[name]) {\n      hybridDb.addCollection(name);\n    }\n  }\n  return hybridDb.upload(success, error);\n};\n\nexports.cloneLocalDb = function(fromDb, toDb, success, error) {\n  var col, name, _ref;\n  _ref = fromDb.collections;\n  for (name in _ref) {\n    col = _ref[name];\n    if (!toDb[name]) {\n      toDb.addCollection(name);\n    }\n  }\n  return async.each(_.values(fromDb.collections), (function(_this) {\n    return function(fromCol, cb) {\n      var toCol;\n      toCol = toDb[fromCol.name];\n      return fromCol.find({}).fetch(function(items) {\n        return toCol.seed(items, function() {\n          return fromCol.pendingUpserts(function(upserts) {\n            return toCol.upsert(_.pluck(upserts, \"doc\"), _.pluck(upserts, \"base\"), function() {\n              return fromCol.pendingRemoves(function(removes) {\n                return async.eachSeries(removes, function(remove, cb2) {\n                  return toCol.remove(remove, function() {\n                    return cb2();\n                  }, cb2);\n                }, cb);\n              }, cb);\n            }, cb);\n          }, cb);\n        }, cb);\n      }, cb);\n    };\n  })(this), (function(_this) {\n    return function(err) {\n      if (err) {\n        return error(err);\n      }\n      return success();\n    };\n  })(this));\n};\n\nexports.processFind = function(items, selector, options) {\n  var filtered;\n  filtered = _.filter(items, compileDocumentSelector(selector));\n  filtered = processNearOperator(selector, filtered);\n  filtered = processGeoIntersectsOperator(selector, filtered);\n  if (options && options.sort) {\n    filtered.sort(compileSort(options.sort));\n  }\n  if (options && options.skip) {\n    filtered = _.slice(filtered, options.skip);\n  }\n  if (options && options.limit) {\n    filtered = _.take(filtered, options.limit);\n  }\n  if (options && options.fields) {\n    filtered = exports.filterFields(filtered, options.fields);\n  }\n  filtered = JSON.parse(JSON.stringify(filtered));\n  return filtered;\n};\n\nexports.filterFields = function(items, fields) {\n  if (fields == null) {\n    fields = {};\n  }\n  if (_.keys(fields).length === 0) {\n    return items;\n  }\n  return _.map(items, function(item) {\n    var field, from, newItem, obj, path, pathElem, to, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3;\n    newItem = {};\n    if (_.first(_.values(fields)) === 1) {\n      _ref = _.keys(fields).concat([\"_id\"]);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        field = _ref[_i];\n        path = field.split(\".\");\n        obj = item;\n        for (_j = 0, _len1 = path.length; _j < _len1; _j++) {\n          pathElem = path[_j];\n          if (obj) {\n            obj = obj[pathElem];\n          }\n        }\n        if (obj == null) {\n          continue;\n        }\n        from = item;\n        to = newItem;\n        _ref1 = _.initial(path);\n        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {\n          pathElem = _ref1[_k];\n          to[pathElem] = to[pathElem] || {};\n          to = to[pathElem];\n          from = from[pathElem];\n        }\n        to[_.last(path)] = from[_.last(path)];\n      }\n      return newItem;\n    } else {\n      item = _.cloneDeep(item);\n      _ref2 = _.keys(fields);\n      for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {\n        field = _ref2[_l];\n        path = field.split(\".\");\n        obj = item;\n        _ref3 = _.initial(path);\n        for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {\n          pathElem = _ref3[_m];\n          if (obj) {\n            obj = obj[pathElem];\n          }\n        }\n        if (obj == null) {\n          continue;\n        }\n        delete obj[_.last(path)];\n      }\n      return item;\n    }\n  });\n};\n\nexports.createUid = function() {\n  return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    var r, v;\n    r = Math.random() * 16 | 0;\n    v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n};\n\nprocessNearOperator = function(selector, list) {\n  var distances, geo, key, value;\n  for (key in selector) {\n    value = selector[key];\n    if ((value != null) && value['$near']) {\n      geo = value['$near']['$geometry'];\n      if (geo.type !== 'Point') {\n        break;\n      }\n      list = _.filter(list, function(doc) {\n        return doc[key] && doc[key].type === 'Point';\n      });\n      distances = _.map(list, function(doc) {\n        return {\n          doc: doc,\n          distance: getDistanceFromLatLngInM(geo.coordinates[1], geo.coordinates[0], doc[key].coordinates[1], doc[key].coordinates[0])\n        };\n      });\n      distances = _.filter(distances, function(item) {\n        return item.distance >= 0;\n      });\n      distances = _.sortBy(distances, 'distance');\n      if (value['$near']['$maxDistance']) {\n        distances = _.filter(distances, function(item) {\n          return item.distance <= value['$near']['$maxDistance'];\n        });\n      }\n      list = _.pluck(distances, 'doc');\n    }\n  }\n  return list;\n};\n\npointInPolygon = function(point, polygon) {\n  if (!_.isEqual(_.first(polygon.coordinates[0]), _.last(polygon.coordinates[0]))) {\n    throw new Error(\"First must equal last\");\n  }\n  if (point.coordinates[0] < Math.min.apply(this, _.map(polygon.coordinates[0], function(coord) {\n    return coord[0];\n  }))) {\n    return false;\n  }\n  if (point.coordinates[1] < Math.min.apply(this, _.map(polygon.coordinates[0], function(coord) {\n    return coord[1];\n  }))) {\n    return false;\n  }\n  if (point.coordinates[0] > Math.max.apply(this, _.map(polygon.coordinates[0], function(coord) {\n    return coord[0];\n  }))) {\n    return false;\n  }\n  if (point.coordinates[1] > Math.max.apply(this, _.map(polygon.coordinates[0], function(coord) {\n    return coord[1];\n  }))) {\n    return false;\n  }\n  return true;\n};\n\ngetDistanceFromLatLngInM = function(lat1, lng1, lat2, lng2) {\n  var R, a, c, d, dLat, dLng;\n  R = 6370986;\n  dLat = deg2rad(lat2 - lat1);\n  dLng = deg2rad(lng2 - lng1);\n  a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.sin(dLng / 2) * Math.sin(dLng / 2);\n  c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  d = R * c;\n  return d;\n};\n\ndeg2rad = function(deg) {\n  return deg * (Math.PI / 180);\n};\n\nprocessGeoIntersectsOperator = function(selector, list) {\n  var geo, key, value;\n  for (key in selector) {\n    value = selector[key];\n    if ((value != null) && value['$geoIntersects']) {\n      geo = value['$geoIntersects']['$geometry'];\n      if (geo.type !== 'Polygon') {\n        break;\n      }\n      list = _.filter(list, function(doc) {\n        if (!doc[key] || doc[key].type !== 'Point') {\n          return false;\n        }\n        return pointInPolygon(doc[key], geo);\n      });\n    }\n  }\n  return list;\n};\n\nexports.regularizeUpsert = function(docs, bases, success, error) {\n  var item, items, _i, _len, _ref;\n  if (_.isFunction(bases)) {\n    _ref = [void 0, bases, success], bases = _ref[0], success = _ref[1], error = _ref[2];\n  }\n  if (!_.isArray(docs)) {\n    docs = [docs];\n    bases = [bases];\n  } else {\n    bases = bases || [];\n  }\n  items = _.map(docs, function(doc, i) {\n    return {\n      doc: doc,\n      base: i < bases.length ? bases[i] : void 0\n    };\n  });\n  for (_i = 0, _len = items.length; _i < _len; _i++) {\n    item = items[_i];\n    if (!item.doc._id) {\n      item.doc._id = exports.createUid();\n    }\n    if (item.base && !item.base._id) {\n      throw new Error(\"Base needs _id\");\n    }\n    if (item.base && item.base._id !== item.doc._id) {\n      throw new Error(\"Base needs same _id\");\n    }\n  }\n  return [items, success, error];\n};\n","/home/travis/build/npmtest/node-npmtest-minimongo/node_modules/minimongo/lib/selector.js":"/*\n========================================\nMeteor is licensed under the MIT License\n========================================\n\nCopyright (C) 2011--2012 Meteor Development Group\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n====================================================================\nThis license applies to all code in Meteor that is not an externally\nmaintained library. Externally maintained libraries have their own\nlicenses, included below:\n====================================================================\n\n*/\n\nLocalCollection = {};\nEJSON = require(\"./EJSON\");\nvar _ = require('lodash');\n\n\n// Like _.isArray, but doesn't regard polyfilled Uint8Arrays on old browsers as\n// arrays.\nvar isArray = function (x) {\n  return _.isArray(x) && !EJSON.isBinary(x);\n};\n\nvar _anyIfArray = function (x, f) {\n  if (isArray(x))\n    return _.any(x, f);\n  return f(x);\n};\n\nvar _anyIfArrayPlus = function (x, f) {\n  if (f(x))\n    return true;\n  return isArray(x) && _.any(x, f);\n};\n\nvar hasOperators = function(valueSelector) {\n  var theseAreOperators = undefined;\n  for (var selKey in valueSelector) {\n    var thisIsOperator = selKey.substr(0, 1) === '$';\n    if (theseAreOperators === undefined) {\n      theseAreOperators = thisIsOperator;\n    } else if (theseAreOperators !== thisIsOperator) {\n      throw new Error(\"Inconsistent selector: \" + valueSelector);\n    }\n  }\n  return !!theseAreOperators;  // {} has no operators\n};\n\nvar compileValueSelector = function (valueSelector) {\n  if (valueSelector == null) {  // undefined or null\n    return function (value) {\n      return _anyIfArray(value, function (x) {\n        return x == null;  // undefined or null\n      });\n    };\n  }\n\n  // Selector is a non-null primitive (and not an array or RegExp either).\n  if (!_.isObject(valueSelector)) {\n    return function (value) {\n      return _anyIfArray(value, function (x) {\n        return x === valueSelector;\n      });\n    };\n  }\n\n  if (valueSelector instanceof RegExp) {\n    return function (value) {\n      if (value === undefined)\n        return false;\n      return _anyIfArray(value, function (x) {\n        return valueSelector.test(x);\n      });\n    };\n  }\n\n  // Arrays match either identical arrays or arrays that contain it as a value.\n  if (isArray(valueSelector)) {\n    return function (value) {\n      if (!isArray(value))\n        return false;\n      return _anyIfArrayPlus(value, function (x) {\n        return LocalCollection._f._equal(valueSelector, x);\n      });\n    };\n  }\n\n  // It's an object, but not an array or regexp.\n  if (hasOperators(valueSelector)) {\n    var operatorFunctions = [];\n    _.each(valueSelector, function (operand, operator) {\n      if (!_.has(VALUE_OPERATORS, operator))\n        throw new Error(\"Unrecognized operator: \" + operator);\n      operatorFunctions.push(VALUE_OPERATORS[operator](\n        operand, valueSelector.$options));\n    });\n    return function (value) {\n      return _.all(operatorFunctions, function (f) {\n        return f(value);\n      });\n    };\n  }\n\n  // It's a literal; compare value (or element of value array) directly to the\n  // selector.\n  return function (value) {\n    return _anyIfArray(value, function (x) {\n      return LocalCollection._f._equal(valueSelector, x);\n    });\n  };\n};\n\n// XXX can factor out common logic below\nvar LOGICAL_OPERATORS = {\n  \"$and\": function(subSelector) {\n    if (!isArray(subSelector) || _.isEmpty(subSelector))\n      throw Error(\"$and/$or/$nor must be nonempty array\");\n    var subSelectorFunctions = _.map(\n      subSelector, compileDocumentSelector);\n    return function (doc) {\n      return _.all(subSelectorFunctions, function (f) {\n        return f(doc);\n      });\n    };\n  },\n\n  \"$or\": function(subSelector) {\n    if (!isArray(subSelector) || _.isEmpty(subSelector))\n      throw Error(\"$and/$or/$nor must be nonempty array\");\n    var subSelectorFunctions = _.map(\n      subSelector, compileDocumentSelector);\n    return function (doc) {\n      return _.any(subSelectorFunctions, function (f) {\n        return f(doc);\n      });\n    };\n  },\n\n  \"$nor\": function(subSelector) {\n    if (!isArray(subSelector) || _.isEmpty(subSelector))\n      throw Error(\"$and/$or/$nor must be nonempty array\");\n    var subSelectorFunctions = _.map(\n      subSelector, compileDocumentSelector);\n    return function (doc) {\n      return _.all(subSelectorFunctions, function (f) {\n        return !f(doc);\n      });\n    };\n  },\n\n  \"$where\": function(selectorValue) {\n    if (!(selectorValue instanceof Function)) {\n      selectorValue = Function(\"return \" + selectorValue);\n    }\n    return function (doc) {\n      return selectorValue.call(doc);\n    };\n  }\n};\n\nvar VALUE_OPERATORS = {\n  \"$in\": function (operand) {\n    if (!isArray(operand))\n      throw new Error(\"Argument to $in must be array\");\n\n    // Create index if all strings\n    var index = null;\n    if (_.all(operand, _.isString))\n      index = _.indexBy(operand);\n\n    return function (value) {\n      return _anyIfArrayPlus(value, function (x) {\n        if (_.isString(x) && index !== null)\n          return index[x] != undefined;\n        \n        return _.any(operand, function (operandElt) {\n          return LocalCollection._f._equal(operandElt, x);\n        });\n      });\n    };\n  },\n\n  \"$all\": function (operand) {\n    if (!isArray(operand))\n      throw new Error(\"Argument to $all must be array\");\n    return function (value) {\n      if (!isArray(value))\n        return false;\n      return _.all(operand, function (operandElt) {\n        return _.any(value, function (valueElt) {\n          return LocalCollection._f._equal(operandElt, valueElt);\n        });\n      });\n    };\n  },\n\n  \"$lt\": function (operand) {\n    return function (value) {\n      return _anyIfArray(value, function (x) {\n        return LocalCollection._f._cmp(x, operand) < 0;\n      });\n    };\n  },\n\n  \"$lte\": function (operand) {\n    return function (value) {\n      return _anyIfArray(value, function (x) {\n        return LocalCollection._f._cmp(x, operand) <= 0;\n      });\n    };\n  },\n\n  \"$gt\": function (operand) {\n    return function (value) {\n      return _anyIfArray(value, function (x) {\n        return LocalCollection._f._cmp(x, operand) > 0;\n      });\n    };\n  },\n\n  \"$gte\": function (operand) {\n    return function (value) {\n      return _anyIfArray(value, function (x) {\n        return LocalCollection._f._cmp(x, operand) >= 0;\n      });\n    };\n  },\n\n  \"$ne\": function (operand) {\n    return function (value) {\n      return ! _anyIfArrayPlus(value, function (x) {\n        return LocalCollection._f._equal(x, operand);\n      });\n    };\n  },\n\n  \"$nin\": function (operand) {\n    if (!isArray(operand))\n      throw new Error(\"Argument to $nin must be array\");\n    var inFunction = VALUE_OPERATORS.$in(operand);\n    return function (value) {\n      // Field doesn't exist, so it's not-in operand\n      if (value === undefined)\n        return true;\n      return !inFunction(value);\n    };\n  },\n\n  \"$exists\": function (operand) {\n    return function (value) {\n      return operand === (value !== undefined);\n    };\n  },\n\n  \"$mod\": function (operand) {\n    var divisor = operand[0],\n        remainder = operand[1];\n    return function (value) {\n      return _anyIfArray(value, function (x) {\n        return x % divisor === remainder;\n      });\n    };\n  },\n\n  \"$size\": function (operand) {\n    return function (value) {\n      return isArray(value) && operand === value.length;\n    };\n  },\n\n  \"$type\": function (operand) {\n    return function (value) {\n      // A nonexistent field is of no type.\n      if (value === undefined)\n        return false;\n      // Definitely not _anyIfArrayPlus: $type: 4 only matches arrays that have\n      // arrays as elements according to the Mongo docs.\n      return _anyIfArray(value, function (x) {\n        return LocalCollection._f._type(x) === operand;\n      });\n    };\n  },\n\n  \"$regex\": function (operand, options) {\n    if (options !== undefined) {\n      // Options passed in $options (even the empty string) always overrides\n      // options in the RegExp object itself.\n\n      // Be clear that we only support the JS-supported options, not extended\n      // ones (eg, Mongo supports x and s). Ideally we would implement x and s\n      // by transforming the regexp, but not today...\n      if (/[^gim]/.test(options))\n        throw new Error(\"Only the i, m, and g regexp options are supported\");\n\n      var regexSource = operand instanceof RegExp ? operand.source : operand;\n      operand = new RegExp(regexSource, options);\n    } else if (!(operand instanceof RegExp)) {\n      operand = new RegExp(operand);\n    }\n\n    return function (value) {\n      if (value === undefined)\n        return false;\n      return _anyIfArray(value, function (x) {\n        return operand.test(x);\n      });\n    };\n  },\n\n  \"$options\": function (operand) {\n    // evaluation happens at the $regex function above\n    return function (value) { return true; };\n  },\n\n  \"$elemMatch\": function (operand) {\n    var matcher = compileDocumentSelector(operand);\n    return function (value) {\n      if (!isArray(value))\n        return false;\n      return _.any(value, function (x) {\n        return matcher(x);\n      });\n    };\n  },\n\n  \"$not\": function (operand) {\n    var matcher = compileValueSelector(operand);\n    return function (value) {\n      return !matcher(value);\n    };\n  },\n\n  \"$near\": function (operand) {\n    // Always returns true. Must be handled in post-filter/sort/limit\n    return function (value) {\n      return true;\n    }\n  },\n\n  \"$geoIntersects\": function (operand) {\n    // Always returns true. Must be handled in post-filter/sort/limit\n    return function (value) {\n      return true;\n    }\n  }\n\n};\n\n// helpers used by compiled selector code\nLocalCollection._f = {\n  // XXX for _all and _in, consider building 'inquery' at compile time..\n\n  _type: function (v) {\n    if (typeof v === \"number\")\n      return 1;\n    if (typeof v === \"string\")\n      return 2;\n    if (typeof v === \"boolean\")\n      return 8;\n    if (isArray(v))\n      return 4;\n    if (v === null)\n      return 10;\n    if (v instanceof RegExp)\n      return 11;\n    if (typeof v === \"function\")\n      // note that typeof(/x/) === \"function\"\n      return 13;\n    if (v instanceof Date)\n      return 9;\n    if (EJSON.isBinary(v))\n      return 5;\n    if (v instanceof Meteor.Collection.ObjectID)\n      return 7;\n    return 3; // object\n\n    // XXX support some/all of these:\n    // 14, symbol\n    // 15, javascript code with scope\n    // 16, 18: 32-bit/64-bit integer\n    // 17, timestamp\n    // 255, minkey\n    // 127, maxkey\n  },\n\n  // deep equality test: use for literal document and array matches\n  _equal: function (a, b) {\n    return EJSON.equals(a, b, {keyOrderSensitive: true});\n  },\n\n  // maps a type code to a value that can be used to sort values of\n  // different types\n  _typeorder: function (t) {\n    // http://www.mongodb.org/display/DOCS/What+is+the+Compare+Order+for+BSON+Types\n    // XXX what is the correct sort position for Javascript code?\n    // ('100' in the matrix below)\n    // XXX minkey/maxkey\n    return [-1,  // (not a type)\n            1,   // number\n            2,   // string\n            3,   // object\n            4,   // array\n            5,   // binary\n            -1,  // deprecated\n            6,   // ObjectID\n            7,   // bool\n            8,   // Date\n            0,   // null\n            9,   // RegExp\n            -1,  // deprecated\n            100, // JS code\n            2,   // deprecated (symbol)\n            100, // JS code\n            1,   // 32-bit int\n            8,   // Mongo timestamp\n            1    // 64-bit int\n           ][t];\n  },\n\n  // compare two values of unknown type according to BSON ordering\n  // semantics. (as an extension, consider 'undefined' to be less than\n  // any other value.) return negative if a is less, positive if b is\n  // less, or 0 if equal\n  _cmp: function (a, b) {\n    if (a === undefined)\n      return b === undefined ? 0 : -1;\n    if (b === undefined)\n      return 1;\n    var ta = LocalCollection._f._type(a);\n    var tb = LocalCollection._f._type(b);\n    var oa = LocalCollection._f._typeorder(ta);\n    var ob = LocalCollection._f._typeorder(tb);\n    if (oa !== ob)\n      return oa < ob ? -1 : 1;\n    if (ta !== tb)\n      // XXX need to implement this if we implement Symbol or integers, or\n      // Timestamp\n      throw Error(\"Missing type coercion logic in _cmp\");\n    if (ta === 7) { // ObjectID\n      // Convert to string.\n      ta = tb = 2;\n      a = a.toHexString();\n      b = b.toHexString();\n    }\n    if (ta === 9) { // Date\n      // Convert to millis.\n      ta = tb = 1;\n      a = a.getTime();\n      b = b.getTime();\n    }\n\n    if (ta === 1) // double\n      return a - b;\n    if (tb === 2) // string\n      return a < b ? -1 : (a === b ? 0 : 1);\n    if (ta === 3) { // Object\n      // this could be much more efficient in the expected case ...\n      var to_array = function (obj) {\n        var ret = [];\n        for (var key in obj) {\n          ret.push(key);\n          ret.push(obj[key]);\n        }\n        return ret;\n      };\n      return LocalCollection._f._cmp(to_array(a), to_array(b));\n    }\n    if (ta === 4) { // Array\n      for (var i = 0; ; i++) {\n        if (i === a.length)\n          return (i === b.length) ? 0 : -1;\n        if (i === b.length)\n          return 1;\n        var s = LocalCollection._f._cmp(a[i], b[i]);\n        if (s !== 0)\n          return s;\n      }\n    }\n    if (ta === 5) { // binary\n      // Surprisingly, a small binary blob is always less than a large one in\n      // Mongo.\n      if (a.length !== b.length)\n        return a.length - b.length;\n      for (i = 0; i < a.length; i++) {\n        if (a[i] < b[i])\n          return -1;\n        if (a[i] > b[i])\n          return 1;\n      }\n      return 0;\n    }\n    if (ta === 8) { // boolean\n      if (a) return b ? 0 : 1;\n      return b ? -1 : 0;\n    }\n    if (ta === 10) // null\n      return 0;\n    if (ta === 11) // regexp\n      throw Error(\"Sorting not supported on regular expression\"); // XXX\n    // 13: javascript code\n    // 14: symbol\n    // 15: javascript code with scope\n    // 16: 32-bit integer\n    // 17: timestamp\n    // 18: 64-bit integer\n    // 255: minkey\n    // 127: maxkey\n    if (ta === 13) // javascript code\n      throw Error(\"Sorting not supported on Javascript code\"); // XXX\n    throw Error(\"Unknown type to sort\");\n  }\n};\n\n// For unit tests. True if the given document matches the given\n// selector.\nLocalCollection._matches = function (selector, doc) {\n  return (LocalCollection._compileSelector(selector))(doc);\n};\n\n// _makeLookupFunction(key) returns a lookup function.\n//\n// A lookup function takes in a document and returns an array of matching\n// values.  This array has more than one element if any segment of the key other\n// than the last one is an array.  ie, any arrays found when doing non-final\n// lookups result in this function \"branching\"; each element in the returned\n// array represents the value found at this branch. If any branch doesn't have a\n// final value for the full key, its element in the returned list will be\n// undefined. It always returns a non-empty array.\n//\n// _makeLookupFunction('a.x')({a: {x: 1}}) returns [1]\n// _makeLookupFunction('a.x')({a: {x: [1]}}) returns [[1]]\n// _makeLookupFunction('a.x')({a: 5})  returns [undefined]\n// _makeLookupFunction('a.x')({a: [{x: 1},\n//                                 {x: [2]},\n//                                 {y: 3}]})\n//   returns [1, [2], undefined]\nLocalCollection._makeLookupFunction = function (key) {\n  var dotLocation = key.indexOf('.');\n  var first, lookupRest, nextIsNumeric;\n  if (dotLocation === -1) {\n    first = key;\n  } else {\n    first = key.substr(0, dotLocation);\n    var rest = key.substr(dotLocation + 1);\n    lookupRest = LocalCollection._makeLookupFunction(rest);\n    // Is the next (perhaps final) piece numeric (ie, an array lookup?)\n    nextIsNumeric = /^\\d+(\\.|$)/.test(rest);\n  }\n\n  return function (doc) {\n    if (doc == null)  // null or undefined\n      return [undefined];\n    var firstLevel = doc[first];\n\n    // We don't \"branch\" at the final level.\n    if (!lookupRest)\n      return [firstLevel];\n\n    // It's an empty array, and we're not done: we won't find anything.\n    if (isArray(firstLevel) && firstLevel.length === 0)\n      return [undefined];\n\n    // For each result at this level, finish the lookup on the rest of the key,\n    // and return everything we find. Also, if the next result is a number,\n    // don't branch here.\n    //\n    // Technically, in MongoDB, we should be able to handle the case where\n    // objects have numeric keys, but Mongo doesn't actually handle this\n    // consistently yet itself, see eg\n    // https://jira.mongodb.org/browse/SERVER-2898\n    // https://github.com/mongodb/mongo/blob/master/jstests/array_match2.js\n    if (!isArray(firstLevel) || nextIsNumeric)\n      firstLevel = [firstLevel];\n    return Array.prototype.concat.apply([], _.map(firstLevel, lookupRest));\n  };\n};\n\n// The main compilation function for a given selector.\nvar compileDocumentSelector = function (docSelector) {\n  var perKeySelectors = [];\n  _.each(docSelector, function (subSelector, key) {\n    if (key.substr(0, 1) === '$') {\n      // Outer operators are either logical operators (they recurse back into\n      // this function), or $where.\n      if (!_.has(LOGICAL_OPERATORS, key))\n        throw new Error(\"Unrecognized logical operator: \" + key);\n      perKeySelectors.push(LOGICAL_OPERATORS[key](subSelector));\n    } else {\n      var lookUpByIndex = LocalCollection._makeLookupFunction(key);\n      var valueSelectorFunc = compileValueSelector(subSelector);\n      perKeySelectors.push(function (doc) {\n        var branchValues = lookUpByIndex(doc);\n        // We apply the selector to each \"branched\" value and return true if any\n        // match. This isn't 100% consistent with MongoDB; eg, see:\n        // https://jira.mongodb.org/browse/SERVER-8585\n        return _.any(branchValues, valueSelectorFunc);\n      });\n    }\n  });\n\n\n  return function (doc) {\n    return _.all(perKeySelectors, function (f) {\n      return f(doc);\n    });\n  };\n};\n\n// Given a selector, return a function that takes one argument, a\n// document, and returns true if the document matches the selector,\n// else false.\nLocalCollection._compileSelector = function (selector) {\n  // you can pass a literal function instead of a selector\n  if (selector instanceof Function)\n    return function (doc) {return selector.call(doc);};\n\n  // shorthand -- scalars match _id\n  if (LocalCollection._selectorIsId(selector)) {\n    return function (doc) {\n      return EJSON.equals(doc._id, selector);\n    };\n  }\n\n  // protect against dangerous selectors.  falsey and {_id: falsey} are both\n  // likely programmer error, and not what you want, particularly for\n  // destructive operations.\n  if (!selector || (('_id' in selector) && !selector._id))\n    return function (doc) {return false;};\n\n  // Top level can't be an array or true or binary.\n  if (typeof(selector) === 'boolean' || isArray(selector) ||\n      EJSON.isBinary(selector))\n    throw new Error(\"Invalid selector: \" + selector);\n\n  return compileDocumentSelector(selector);\n};\n\n// Give a sort spec, which can be in any of these forms:\n//   {\"key1\": 1, \"key2\": -1}\n//   [[\"key1\", \"asc\"], [\"key2\", \"desc\"]]\n//   [\"key1\", [\"key2\", \"desc\"]]\n//\n// (.. with the first form being dependent on the key enumeration\n// behavior of your javascript VM, which usually does what you mean in\n// this case if the key names don't look like integers ..)\n//\n// return a function that takes two objects, and returns -1 if the\n// first object comes first in order, 1 if the second object comes\n// first, or 0 if neither object comes before the other.\n\nLocalCollection._compileSort = function (spec) {\n  var sortSpecParts = [];\n\n  if (spec instanceof Array) {\n    for (var i = 0; i < spec.length; i++) {\n      if (typeof spec[i] === \"string\") {\n        sortSpecParts.push({\n          lookup: LocalCollection._makeLookupFunction(spec[i]),\n          ascending: true\n        });\n      } else {\n        sortSpecParts.push({\n          lookup: LocalCollection._makeLookupFunction(spec[i][0]),\n          ascending: spec[i][1] !== \"desc\"\n        });\n      }\n    }\n  } else if (typeof spec === \"object\") {\n    for (var key in spec) {\n      sortSpecParts.push({\n        lookup: LocalCollection._makeLookupFunction(key),\n        ascending: spec[key] >= 0\n      });\n    }\n  } else {\n    throw Error(\"Bad sort specification: \", JSON.stringify(spec));\n  }\n\n  if (sortSpecParts.length === 0)\n    return function () {return 0;};\n\n  // reduceValue takes in all the possible values for the sort key along various\n  // branches, and returns the min or max value (according to the bool\n  // findMin). Each value can itself be an array, and we look at its values\n  // too. (ie, we do a single level of flattening on branchValues, then find the\n  // min/max.)\n  var reduceValue = function (branchValues, findMin) {\n    var reduced;\n    var first = true;\n    // Iterate over all the values found in all the branches, and if a value is\n    // an array itself, iterate over the values in the array separately.\n    _.each(branchValues, function (branchValue) {\n      // Value not an array? Pretend it is.\n      if (!isArray(branchValue))\n        branchValue = [branchValue];\n      // Value is an empty array? Pretend it was missing, since that's where it\n      // should be sorted.\n      if (isArray(branchValue) && branchValue.length === 0)\n        branchValue = [undefined];\n      _.each(branchValue, function (value) {\n        // We should get here at least once: lookup functions return non-empty\n        // arrays, so the outer loop runs at least once, and we prevented\n        // branchValue from being an empty array.\n        if (first) {\n          reduced = value;\n          first = false;\n        } else {\n          // Compare the value we found to the value we found so far, saving it\n          // if it's less (for an ascending sort) or more (for a descending\n          // sort).\n          var cmp = LocalCollection._f._cmp(reduced, value);\n          if ((findMin && cmp > 0) || (!findMin && cmp < 0))\n            reduced = value;\n        }\n      });\n    });\n    return reduced;\n  };\n\n  return function (a, b) {\n    for (var i = 0; i < sortSpecParts.length; ++i) {\n      var specPart = sortSpecParts[i];\n      var aValue = reduceValue(specPart.lookup(a), specPart.ascending);\n      var bValue = reduceValue(specPart.lookup(b), specPart.ascending);\n      var compare = LocalCollection._f._cmp(aValue, bValue);\n      if (compare !== 0)\n        return specPart.ascending ? compare : -compare;\n    };\n    return 0;\n  };\n};\n\nexports.compileDocumentSelector = compileDocumentSelector;\nexports.compileSort = LocalCollection._compileSort;\n","/home/travis/build/npmtest/node-npmtest-minimongo/node_modules/minimongo/lib/EJSON.js":"var _ = require('lodash');\n\nEJSON = {}; // Global!\nvar customTypes = {};\n// Add a custom type, using a method of your choice to get to and\n// from a basic JSON-able representation.  The factory argument\n// is a function of JSON-able --> your object\n// The type you add must have:\n// - A clone() method, so that Meteor can deep-copy it when necessary.\n// - A equals() method, so that Meteor can compare it\n// - A toJSONValue() method, so that Meteor can serialize it\n// - a typeName() method, to show how to look it up in our type table.\n// It is okay if these methods are monkey-patched on.\nEJSON.addType = function (name, factory) {\n  if (_.has(customTypes, name))\n    throw new Error(\"Type \" + name + \" already present\");\n  customTypes[name] = factory;\n};\n\nvar builtinConverters = [\n  { // Date\n    matchJSONValue: function (obj) {\n      return _.has(obj, '$date') && _.size(obj) === 1;\n    },\n    matchObject: function (obj) {\n      return obj instanceof Date;\n    },\n    toJSONValue: function (obj) {\n      return {$date: obj.getTime()};\n    },\n    fromJSONValue: function (obj) {\n      return new Date(obj.$date);\n    }\n  },\n  { // Binary\n    matchJSONValue: function (obj) {\n      return _.has(obj, '$binary') && _.size(obj) === 1;\n    },\n    matchObject: function (obj) {\n      return typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array\n        || (obj && _.has(obj, '$Uint8ArrayPolyfill'));\n    },\n    toJSONValue: function (obj) {\n      return {$binary: EJSON._base64Encode(obj)};\n    },\n    fromJSONValue: function (obj) {\n      return EJSON._base64Decode(obj.$binary);\n    }\n  },\n  { // Escaping one level\n    matchJSONValue: function (obj) {\n      return _.has(obj, '$escape') && _.size(obj) === 1;\n    },\n    matchObject: function (obj) {\n      if (_.isEmpty(obj) || _.size(obj) > 2) {\n        return false;\n      }\n      return _.any(builtinConverters, function (converter) {\n        return converter.matchJSONValue(obj);\n      });\n    },\n    toJSONValue: function (obj) {\n      var newObj = {};\n      _.each(obj, function (value, key) {\n        newObj[key] = EJSON.toJSONValue(value);\n      });\n      return {$escape: newObj};\n    },\n    fromJSONValue: function (obj) {\n      var newObj = {};\n      _.each(obj.$escape, function (value, key) {\n        newObj[key] = EJSON.fromJSONValue(value);\n      });\n      return newObj;\n    }\n  },\n  { // Custom\n    matchJSONValue: function (obj) {\n      return _.has(obj, '$type') && _.has(obj, '$value') && _.size(obj) === 2;\n    },\n    matchObject: function (obj) {\n      return EJSON._isCustomType(obj);\n    },\n    toJSONValue: function (obj) {\n      return {$type: obj.typeName(), $value: obj.toJSONValue()};\n    },\n    fromJSONValue: function (obj) {\n      var typeName = obj.$type;\n      var converter = customTypes[typeName];\n      return converter(obj.$value);\n    }\n  }\n];\n\nEJSON._isCustomType = function (obj) {\n  return obj &&\n    typeof obj.toJSONValue === 'function' &&\n    typeof obj.typeName === 'function' &&\n    _.has(customTypes, obj.typeName());\n};\n\n\n//for both arrays and objects, in-place modification.\nvar adjustTypesToJSONValue =\nEJSON._adjustTypesToJSONValue = function (obj) {\n  if (obj === null)\n    return null;\n  var maybeChanged = toJSONValueHelper(obj);\n  if (maybeChanged !== undefined)\n    return maybeChanged;\n  _.each(obj, function (value, key) {\n    if (typeof value !== 'object' && value !== undefined)\n      return; // continue\n    var changed = toJSONValueHelper(value);\n    if (changed) {\n      obj[key] = changed;\n      return; // on to the next key\n    }\n    // if we get here, value is an object but not adjustable\n    // at this level.  recurse.\n    adjustTypesToJSONValue(value);\n  });\n  return obj;\n};\n\n// Either return the JSON-compatible version of the argument, or undefined (if\n// the item isn't itself replaceable, but maybe some fields in it are)\nvar toJSONValueHelper = function (item) {\n  for (var i = 0; i < builtinConverters.length; i++) {\n    var converter = builtinConverters[i];\n    if (converter.matchObject(item)) {\n      return converter.toJSONValue(item);\n    }\n  }\n  return undefined;\n};\n\nEJSON.toJSONValue = function (item) {\n  var changed = toJSONValueHelper(item);\n  if (changed !== undefined)\n    return changed;\n  if (typeof item === 'object') {\n    item = EJSON.clone(item);\n    adjustTypesToJSONValue(item);\n  }\n  return item;\n};\n\n//for both arrays and objects. Tries its best to just\n// use the object you hand it, but may return something\n// different if the object you hand it itself needs changing.\nvar adjustTypesFromJSONValue =\nEJSON._adjustTypesFromJSONValue = function (obj) {\n  if (obj === null)\n    return null;\n  var maybeChanged = fromJSONValueHelper(obj);\n  if (maybeChanged !== obj)\n    return maybeChanged;\n  _.each(obj, function (value, key) {\n    if (typeof value === 'object') {\n      var changed = fromJSONValueHelper(value);\n      if (value !== changed) {\n        obj[key] = changed;\n        return;\n      }\n      // if we get here, value is an object but not adjustable\n      // at this level.  recurse.\n      adjustTypesFromJSONValue(value);\n    }\n  });\n  return obj;\n};\n\n// Either return the argument changed to have the non-json\n// rep of itself (the Object version) or the argument itself.\n\n// DOES NOT RECURSE.  For actually getting the fully-changed value, use\n// EJSON.fromJSONValue\nvar fromJSONValueHelper = function (value) {\n  if (typeof value === 'object' && value !== null) {\n    if (_.size(value) <= 2\n        && _.all(value, function (v, k) {\n          return typeof k === 'string' && k.substr(0, 1) === '$';\n        })) {\n      for (var i = 0; i < builtinConverters.length; i++) {\n        var converter = builtinConverters[i];\n        if (converter.matchJSONValue(value)) {\n          return converter.fromJSONValue(value);\n        }\n      }\n    }\n  }\n  return value;\n};\n\nEJSON.fromJSONValue = function (item) {\n  var changed = fromJSONValueHelper(item);\n  if (changed === item && typeof item === 'object') {\n    item = EJSON.clone(item);\n    adjustTypesFromJSONValue(item);\n    return item;\n  } else {\n    return changed;\n  }\n};\n\nEJSON.stringify = function (item) {\n  return JSON.stringify(EJSON.toJSONValue(item));\n};\n\nEJSON.parse = function (item) {\n  return EJSON.fromJSONValue(JSON.parse(item));\n};\n\nEJSON.isBinary = function (obj) {\n  return (typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array) ||\n    (obj && obj.$Uint8ArrayPolyfill);\n};\n\nEJSON.equals = function (a, b, options) {\n  var i;\n  var keyOrderSensitive = !!(options && options.keyOrderSensitive);\n  if (a === b)\n    return true;\n  if (!a || !b) // if either one is falsy, they'd have to be === to be equal\n    return false;\n  if (!(typeof a === 'object' && typeof b === 'object'))\n    return false;\n  if (a instanceof Date && b instanceof Date)\n    return a.valueOf() === b.valueOf();\n  if (EJSON.isBinary(a) && EJSON.isBinary(b)) {\n    if (a.length !== b.length)\n      return false;\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i])\n        return false;\n    }\n    return true;\n  }\n  if (typeof (a.equals) === 'function')\n    return a.equals(b, options);\n  if (a instanceof Array) {\n    if (!(b instanceof Array))\n      return false;\n    if (a.length !== b.length)\n      return false;\n    for (i = 0; i < a.length; i++) {\n      if (!EJSON.equals(a[i], b[i], options))\n        return false;\n    }\n    return true;\n  }\n  // fall back to structural equality of objects\n  var ret;\n  if (keyOrderSensitive) {\n    var bKeys = [];\n    _.each(b, function (val, x) {\n        bKeys.push(x);\n    });\n    i = 0;\n    ret = _.all(a, function (val, x) {\n      if (i >= bKeys.length) {\n        return false;\n      }\n      if (x !== bKeys[i]) {\n        return false;\n      }\n      if (!EJSON.equals(val, b[bKeys[i]], options)) {\n        return false;\n      }\n      i++;\n      return true;\n    });\n    return ret && i === bKeys.length;\n  } else {\n    i = 0;\n    ret = _.all(a, function (val, key) {\n      if (!_.has(b, key)) {\n        return false;\n      }\n      if (!EJSON.equals(val, b[key], options)) {\n        return false;\n      }\n      i++;\n      return true;\n    });\n    return ret && _.size(b) === i;\n  }\n};\n\nEJSON.clone = function (v) {\n  var ret;\n  if (typeof v !== \"object\")\n    return v;\n  if (v === null)\n    return null; // null has typeof \"object\"\n  if (v instanceof Date)\n    return new Date(v.getTime());\n  if (EJSON.isBinary(v)) {\n    ret = EJSON.newBinary(v.length);\n    for (var i = 0; i < v.length; i++) {\n      ret[i] = v[i];\n    }\n    return ret;\n  }\n  if (_.isArray(v) || _.isArguments(v)) {\n    // For some reason, _.map doesn't work in this context on Opera (weird test\n    // failures).\n    ret = [];\n    for (i = 0; i < v.length; i++)\n      ret[i] = EJSON.clone(v[i]);\n    return ret;\n  }\n  // handle general user-defined typed Objects if they have a clone method\n  if (typeof v.clone === 'function') {\n    return v.clone();\n  }\n  // handle other objects\n  ret = {};\n  _.each(v, function (value, key) {\n    ret[key] = EJSON.clone(value);\n  });\n  return ret;\n};\n\nmodule.exports = EJSON;\n","/home/travis/build/npmtest/node-npmtest-minimongo/node_modules/minimongo/lib/LocalStorageDb.js":"var Collection, LocalStorageDb, async, compileSort, processFind, utils, _;\n\n_ = require('lodash');\n\nasync = require('async');\n\nutils = require('./utils');\n\nprocessFind = require('./utils').processFind;\n\ncompileSort = require('./selector').compileSort;\n\nmodule.exports = LocalStorageDb = (function() {\n  function LocalStorageDb(options, success) {\n    this.collections = {};\n    if (options && options.namespace && window.localStorage) {\n      this.namespace = options.namespace;\n    }\n    if (success) {\n      success(this);\n    }\n  }\n\n  LocalStorageDb.prototype.addCollection = function(name, success, error) {\n    var collection, namespace;\n    if (this.namespace) {\n      namespace = this.namespace + \".\" + name;\n    }\n    collection = new Collection(name, namespace);\n    this[name] = collection;\n    this.collections[name] = collection;\n    if (success != null) {\n      return success();\n    }\n  };\n\n  LocalStorageDb.prototype.removeCollection = function(name, success, error) {\n    var i, key, keyToMatch, keys, _i, _j, _len, _ref;\n    if (this.namespace && window.localStorage) {\n      keys = [];\n      for (i = _i = 0, _ref = window.localStorage.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n        keys.push(window.localStorage.key(i));\n      }\n      for (_j = 0, _len = keys.length; _j < _len; _j++) {\n        key = keys[_j];\n        keyToMatch = this.namespace + '.' + name;\n        if (key.substring(0, keyToMatch.length) === keyToMatch) {\n          window.localStorage.removeItem(key);\n        }\n      }\n    }\n    delete this[name];\n    delete this.collections[name];\n    if (success != null) {\n      return success();\n    }\n  };\n\n  return LocalStorageDb;\n\n})();\n\nCollection = (function() {\n  function Collection(name, namespace) {\n    this.name = name;\n    this.namespace = namespace;\n    this.items = {};\n    this.upserts = {};\n    this.removes = {};\n    if (window.localStorage && (namespace != null)) {\n      this.loadStorage();\n    }\n  }\n\n  Collection.prototype.loadStorage = function() {\n    var base, i, item, key, removeItems, upsertKeys, _i, _j, _len, _ref;\n    this.itemNamespace = this.namespace + \"_\";\n    for (i = _i = 0, _ref = window.localStorage.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n      key = window.localStorage.key(i);\n      if (key.substring(0, this.itemNamespace.length) === this.itemNamespace) {\n        item = JSON.parse(window.localStorage[key]);\n        this.items[item._id] = item;\n      }\n    }\n    upsertKeys = window.localStorage[this.namespace + \"upserts\"] ? JSON.parse(window.localStorage[this.namespace + \"upserts\"]) : [];\n    for (_j = 0, _len = upsertKeys.length; _j < _len; _j++) {\n      key = upsertKeys[_j];\n      this.upserts[key] = {\n        doc: this.items[key]\n      };\n      base = window.localStorage[this.namespace + \"upsertbase_\" + key] ? JSON.parse(window.localStorage[this.namespace + \"upsertbase_\" + key]) : null;\n      this.upserts[key].base = base;\n    }\n    removeItems = window.localStorage[this.namespace + \"removes\"] ? JSON.parse(window.localStorage[this.namespace + \"removes\"]) : [];\n    return this.removes = _.object(_.pluck(removeItems, \"_id\"), removeItems);\n  };\n\n  Collection.prototype.find = function(selector, options) {\n    return {\n      fetch: (function(_this) {\n        return function(success, error) {\n          return _this._findFetch(selector, options, success, error);\n        };\n      })(this)\n    };\n  };\n\n  Collection.prototype.findOne = function(selector, options, success, error) {\n    var _ref;\n    if (_.isFunction(options)) {\n      _ref = [{}, options, success], options = _ref[0], success = _ref[1], error = _ref[2];\n    }\n    return this.find(selector, options).fetch(function(results) {\n      if (success != null) {\n        return success(results.length > 0 ? results[0] : null);\n      }\n    }, error);\n  };\n\n  Collection.prototype._findFetch = function(selector, options, success, error) {\n    if (success != null) {\n      return success(processFind(_.cloneDeep(_.values(this.items)), selector, options));\n    }\n  };\n\n  Collection.prototype.upsert = function(docs, bases, success, error) {\n    var item, items, _i, _len, _ref;\n    _ref = utils.regularizeUpsert(docs, bases, success, error), items = _ref[0], success = _ref[1], error = _ref[2];\n    items = JSON.parse(JSON.stringify(items));\n    for (_i = 0, _len = items.length; _i < _len; _i++) {\n      item = items[_i];\n      if (item.base === void 0) {\n        if (this.upserts[item.doc._id]) {\n          item.base = this.upserts[item.doc._id].base;\n        } else {\n          item.base = this.items[item.doc._id] || null;\n        }\n      }\n      item = _.cloneDeep(item);\n      this._putItem(item.doc);\n      this._putUpsert(item);\n    }\n    if (success) {\n      return success(docs);\n    }\n  };\n\n  Collection.prototype.remove = function(id, success, error) {\n    if (_.isObject(id)) {\n      this.find(id).fetch((function(_this) {\n        return function(rows) {\n          return async.each(rows, function(row, cb) {\n            return _this.remove(row._id, (function() {\n              return cb();\n            }), cb);\n          }, function() {\n            return success();\n          });\n        };\n      })(this), error);\n      return;\n    }\n    if (_.has(this.items, id)) {\n      this._putRemove(this.items[id]);\n      this._deleteItem(id);\n      this._deleteUpsert(id);\n    } else {\n      this._putRemove({\n        _id: id\n      });\n    }\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype._putItem = function(doc) {\n    this.items[doc._id] = doc;\n    if (this.namespace) {\n      return window.localStorage[this.itemNamespace + doc._id] = JSON.stringify(doc);\n    }\n  };\n\n  Collection.prototype._deleteItem = function(id) {\n    delete this.items[id];\n    if (this.namespace) {\n      return window.localStorage.removeItem(this.itemNamespace + id);\n    }\n  };\n\n  Collection.prototype._putUpsert = function(upsert) {\n    this.upserts[upsert.doc._id] = upsert;\n    if (this.namespace) {\n      window.localStorage[this.namespace + \"upserts\"] = JSON.stringify(_.keys(this.upserts));\n      return window.localStorage[this.namespace + \"upsertbase_\" + upsert.doc._id] = JSON.stringify(upsert.base);\n    }\n  };\n\n  Collection.prototype._deleteUpsert = function(id) {\n    delete this.upserts[id];\n    if (this.namespace) {\n      return window.localStorage[this.namespace + \"upserts\"] = JSON.stringify(_.keys(this.upserts));\n    }\n  };\n\n  Collection.prototype._putRemove = function(doc) {\n    this.removes[doc._id] = doc;\n    if (this.namespace) {\n      return window.localStorage[this.namespace + \"removes\"] = JSON.stringify(_.values(this.removes));\n    }\n  };\n\n  Collection.prototype._deleteRemove = function(id) {\n    delete this.removes[id];\n    if (this.namespace) {\n      return window.localStorage[this.namespace + \"removes\"] = JSON.stringify(_.values(this.removes));\n    }\n  };\n\n  Collection.prototype.cache = function(docs, selector, options, success, error) {\n    var doc, docsMap, sort, _i, _len;\n    for (_i = 0, _len = docs.length; _i < _len; _i++) {\n      doc = docs[_i];\n      this.cacheOne(doc);\n    }\n    docsMap = _.object(_.pluck(docs, \"_id\"), docs);\n    if (options.sort) {\n      sort = compileSort(options.sort);\n    }\n    return this.find(selector, options).fetch((function(_this) {\n      return function(results) {\n        var result, _j, _len1;\n        for (_j = 0, _len1 = results.length; _j < _len1; _j++) {\n          result = results[_j];\n          if (!docsMap[result._id] && !_.has(_this.upserts, result._id)) {\n            if (options.sort && options.limit && docs.length === options.limit) {\n              if (sort(result, _.last(docs)) >= 0) {\n                continue;\n              }\n            }\n            _this._deleteItem(result._id);\n          }\n        }\n        if (success != null) {\n          return success();\n        }\n      };\n    })(this), error);\n  };\n\n  Collection.prototype.pendingUpserts = function(success) {\n    return success(_.values(this.upserts));\n  };\n\n  Collection.prototype.pendingRemoves = function(success) {\n    return success(_.pluck(this.removes, \"_id\"));\n  };\n\n  Collection.prototype.resolveUpserts = function(upserts, success) {\n    var upsert, _i, _len;\n    for (_i = 0, _len = upserts.length; _i < _len; _i++) {\n      upsert = upserts[_i];\n      if (this.upserts[upsert.doc._id]) {\n        if (_.isEqual(upsert.doc, this.upserts[upsert.doc._id].doc)) {\n          this._deleteUpsert(upsert.doc._id);\n        } else {\n          this.upserts[upsert.doc._id].base = upsert.doc;\n          this._putUpsert(this.upserts[upsert.doc._id]);\n        }\n      }\n    }\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype.resolveRemove = function(id, success) {\n    this._deleteRemove(id);\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype.seed = function(docs, success) {\n    var doc, _i, _len;\n    if (!_.isArray(docs)) {\n      docs = [docs];\n    }\n    for (_i = 0, _len = docs.length; _i < _len; _i++) {\n      doc = docs[_i];\n      if (!_.has(this.items, doc._id) && !_.has(this.removes, doc._id)) {\n        this._putItem(doc);\n      }\n    }\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype.cacheOne = function(doc, success) {\n    var existing;\n    if (!_.has(this.upserts, doc._id) && !_.has(this.removes, doc._id)) {\n      existing = this.items[doc._id];\n      if (!existing || !doc._rev || !existing._rev || doc._rev >= existing._rev) {\n        this._putItem(doc);\n      }\n    }\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype.uncache = function(selector, success, error) {\n    var compiledSelector, item, _i, _len, _ref;\n    compiledSelector = utils.compileDocumentSelector(selector);\n    _ref = _.values(this.items);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      item = _ref[_i];\n      if ((this.upserts[item._id] == null) && compiledSelector(item)) {\n        this._deleteItem(item._id);\n      }\n    }\n    if (success != null) {\n      return success();\n    }\n  };\n\n  return Collection;\n\n})();\n","/home/travis/build/npmtest/node-npmtest-minimongo/node_modules/minimongo/lib/IndexedDb.js":"var Collection, IDBStore, IndexedDb, async, compileSort, processFind, utils, _;\n\n_ = require('lodash');\n\nasync = require('async');\n\nIDBStore = require('idb-wrapper');\n\nutils = require('./utils');\n\nprocessFind = require('./utils').processFind;\n\ncompileSort = require('./selector').compileSort;\n\nmodule.exports = IndexedDb = (function() {\n  function IndexedDb(options, success, error) {\n    var ex;\n    this.collections = {};\n    try {\n      this.store = new IDBStore({\n        dbVersion: 1,\n        storeName: 'minimongo_' + options.namespace,\n        keyPath: ['col', 'doc._id'],\n        autoIncrement: false,\n        onStoreReady: (function(_this) {\n          return function() {\n            if (success) {\n              return success(_this);\n            }\n          };\n        })(this),\n        onError: error,\n        indexes: [\n          {\n            name: 'col',\n            keyPath: 'col',\n            unique: false,\n            multiEntry: false\n          }, {\n            name: 'col-state',\n            keyPath: ['col', 'state'],\n            unique: false,\n            multiEntry: false\n          }\n        ]\n      });\n    } catch (_error) {\n      ex = _error;\n      if (error) {\n        error(ex);\n      }\n      return;\n    }\n  }\n\n  IndexedDb.prototype.addCollection = function(name, success, error) {\n    var collection;\n    collection = new Collection(name, this.store);\n    this[name] = collection;\n    this.collections[name] = collection;\n    if (success) {\n      return success();\n    }\n  };\n\n  IndexedDb.prototype.removeCollection = function(name, success, error) {\n    delete this[name];\n    delete this.collections[name];\n    return this.store.query((function(_this) {\n      return function(matches) {\n        var keys;\n        keys = _.map(matches, function(m) {\n          return [m.col, m.doc._id];\n        });\n        if (keys.length > 0) {\n          return _this.store.removeBatch(keys, function() {\n            if (success != null) {\n              return success();\n            }\n          }, error);\n        } else {\n          if (success != null) {\n            return success();\n          }\n        }\n      };\n    })(this), {\n      index: \"col\",\n      keyRange: this.store.makeKeyRange({\n        only: name\n      }),\n      onError: error\n    });\n  };\n\n  return IndexedDb;\n\n})();\n\nCollection = (function() {\n  function Collection(name, store) {\n    this.name = name;\n    this.store = store;\n  }\n\n  Collection.prototype.find = function(selector, options) {\n    return {\n      fetch: (function(_this) {\n        return function(success, error) {\n          return _this._findFetch(selector, options, success, error);\n        };\n      })(this)\n    };\n  };\n\n  Collection.prototype.findOne = function(selector, options, success, error) {\n    var _ref;\n    if (_.isFunction(options)) {\n      _ref = [{}, options, success], options = _ref[0], success = _ref[1], error = _ref[2];\n    }\n    return this.find(selector, options).fetch(function(results) {\n      if (success != null) {\n        return success(results.length > 0 ? results[0] : null);\n      }\n    }, error);\n  };\n\n  Collection.prototype._findFetch = function(selector, options, success, error) {\n    return this.store.query(function(matches) {\n      matches = _.filter(matches, function(m) {\n        return m.state !== \"removed\";\n      });\n      if (success != null) {\n        return success(processFind(_.pluck(matches, \"doc\"), selector, options));\n      }\n    }, {\n      index: \"col\",\n      keyRange: this.store.makeKeyRange({\n        only: this.name\n      }),\n      onError: error\n    });\n  };\n\n  Collection.prototype.upsert = function(docs, bases, success, error) {\n    var items, keys, _ref;\n    _ref = utils.regularizeUpsert(docs, bases, success, error), items = _ref[0], success = _ref[1], error = _ref[2];\n    keys = _.map(items, (function(_this) {\n      return function(item) {\n        return [_this.name, item.doc._id];\n      };\n    })(this));\n    return this.store.getBatch(keys, (function(_this) {\n      return function(records) {\n        var puts;\n        puts = _.map(items, function(item, i) {\n          var base;\n          if (item.base !== void 0) {\n            base = item.base;\n          } else if (records[i] && records[i].doc && records[i].state === \"cached\") {\n            base = records[i].doc;\n          } else if (records[i] && records[i].doc && records[i].state === \"upserted\") {\n            base = records[i].base;\n          } else {\n            base = null;\n          }\n          return {\n            col: _this.name,\n            state: \"upserted\",\n            doc: item.doc,\n            base: base\n          };\n        });\n        return _this.store.putBatch(puts, function() {\n          if (success) {\n            return success(docs);\n          }\n        }, error);\n      };\n    })(this), error);\n  };\n\n  Collection.prototype.remove = function(id, success, error) {\n    if (_.isObject(id)) {\n      this.find(id).fetch((function(_this) {\n        return function(rows) {\n          return async.each(rows, function(row, cb) {\n            return _this.remove(row._id, (function() {\n              return cb();\n            }), cb);\n          }, function() {\n            return success();\n          });\n        };\n      })(this), error);\n      return;\n    }\n    return this.store.get([this.name, id], (function(_this) {\n      return function(record) {\n        if (record == null) {\n          record = {\n            col: _this.name,\n            doc: {\n              _id: id\n            }\n          };\n        }\n        record.state = \"removed\";\n        return _this.store.put(record, function() {\n          if (success) {\n            return success(id);\n          }\n        }, error);\n      };\n    })(this));\n  };\n\n  Collection.prototype.cache = function(docs, selector, options, success, error) {\n    var keys, puts, step2;\n    step2 = (function(_this) {\n      return function() {\n        var docsMap, sort;\n        docsMap = _.object(_.pluck(docs, \"_id\"), docs);\n        if (options.sort) {\n          sort = compileSort(options.sort);\n        }\n        return _this.find(selector, options).fetch(function(results) {\n          var keys, removes;\n          removes = [];\n          keys = _.map(results, function(result) {\n            return [_this.name, result._id];\n          });\n          if (keys.length === 0) {\n            if (success != null) {\n              success();\n            }\n            return;\n          }\n          return _this.store.getBatch(keys, function(records) {\n            var i, record, result, _i, _ref;\n            for (i = _i = 0, _ref = records.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n              record = records[i];\n              result = results[i];\n              if (!docsMap[result._id] && record && record.state === \"cached\") {\n                if (options.sort && options.limit && docs.length === options.limit) {\n                  if (sort(result, _.last(docs)) >= 0) {\n                    continue;\n                  }\n                }\n                removes.push([_this.name, result._id]);\n              }\n            }\n            if (removes.length > 0) {\n              return _this.store.removeBatch(removes, function() {\n                if (success != null) {\n                  return success();\n                }\n              }, error);\n            } else {\n              if (success != null) {\n                return success();\n              }\n            }\n          }, error);\n        }, error);\n      };\n    })(this);\n    if (docs.length === 0) {\n      return step2();\n    }\n    keys = _.map(docs, (function(_this) {\n      return function(doc) {\n        return [_this.name, doc._id];\n      };\n    })(this));\n    puts = [];\n    return this.store.getBatch(keys, (function(_this) {\n      return function(records) {\n        var doc, i, record, _i, _ref;\n        for (i = _i = 0, _ref = records.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n          record = records[i];\n          doc = docs[i];\n          if ((record == null) || record.state === \"cached\") {\n            if (!record || !doc._rev || !record.doc._rev || doc._rev >= record.doc._rev) {\n              puts.push({\n                col: _this.name,\n                state: \"cached\",\n                doc: doc\n              });\n            }\n          }\n        }\n        if (puts.length > 0) {\n          return _this.store.putBatch(puts, step2, error);\n        } else {\n          return step2();\n        }\n      };\n    })(this), error);\n  };\n\n  Collection.prototype.pendingUpserts = function(success, error) {\n    return this.store.query(function(matches) {\n      var upserts;\n      upserts = _.map(matches, function(m) {\n        return {\n          doc: m.doc,\n          base: m.base || null\n        };\n      });\n      if (success != null) {\n        return success(upserts);\n      }\n    }, {\n      index: \"col-state\",\n      keyRange: this.store.makeKeyRange({\n        only: [this.name, \"upserted\"]\n      }),\n      onError: error\n    });\n  };\n\n  Collection.prototype.pendingRemoves = function(success, error) {\n    return this.store.query(function(matches) {\n      if (success != null) {\n        return success(_.pluck(_.pluck(matches, \"doc\"), \"_id\"));\n      }\n    }, {\n      index: \"col-state\",\n      keyRange: this.store.makeKeyRange({\n        only: [this.name, \"removed\"]\n      }),\n      onError: error\n    });\n  };\n\n  Collection.prototype.resolveUpserts = function(upserts, success, error) {\n    var keys;\n    keys = _.map(upserts, (function(_this) {\n      return function(upsert) {\n        return [_this.name, upsert.doc._id];\n      };\n    })(this));\n    return this.store.getBatch(keys, (function(_this) {\n      return function(records) {\n        var i, puts, record, _i, _ref;\n        puts = [];\n        for (i = _i = 0, _ref = upserts.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n          record = records[i];\n          if (record && record.state === \"upserted\") {\n            if (_.isEqual(record.doc, upserts[i].doc)) {\n              record.state = \"cached\";\n              puts.push(record);\n            } else {\n              record.base = upserts[i].doc;\n              puts.push(record);\n            }\n          }\n        }\n        if (puts.length > 0) {\n          return _this.store.putBatch(puts, function() {\n            if (success) {\n              return success();\n            }\n          }, error);\n        } else {\n          if (success) {\n            return success();\n          }\n        }\n      };\n    })(this), error);\n  };\n\n  Collection.prototype.resolveRemove = function(id, success, error) {\n    return this.store.get([this.name, id], (function(_this) {\n      return function(record) {\n        if (!record) {\n          if (success != null) {\n            success();\n          }\n          return;\n        }\n        if (record.state === \"removed\") {\n          return _this.store.remove([_this.name, id], function() {\n            if (success != null) {\n              return success();\n            }\n          }, error);\n        }\n      };\n    })(this));\n  };\n\n  Collection.prototype.seed = function(docs, success, error) {\n    var keys, puts;\n    if (!_.isArray(docs)) {\n      docs = [docs];\n    }\n    keys = _.map(docs, (function(_this) {\n      return function(doc) {\n        return [_this.name, doc._id];\n      };\n    })(this));\n    puts = [];\n    return this.store.getBatch(keys, (function(_this) {\n      return function(records) {\n        var doc, i, record, _i, _ref;\n        for (i = _i = 0, _ref = records.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n          record = records[i];\n          doc = docs[i];\n          if (record == null) {\n            puts.push({\n              col: _this.name,\n              state: \"cached\",\n              doc: doc\n            });\n          }\n        }\n        if (puts.length > 0) {\n          return _this.store.putBatch(puts, function() {\n            if (success != null) {\n              return success();\n            }\n          }, error);\n        } else {\n          if (success != null) {\n            return success();\n          }\n        }\n      };\n    })(this), error);\n  };\n\n  Collection.prototype.cacheOne = function(doc, success, error) {\n    return this.store.get([this.name, doc._id], (function(_this) {\n      return function(record) {\n        if (record && doc._rev && record.doc._rev && doc._rev < record.doc._rev) {\n          if (success != null) {\n            success();\n          }\n          return;\n        }\n        if (record == null) {\n          record = {\n            col: _this.name,\n            state: \"cached\",\n            doc: doc\n          };\n        }\n        if (record.state === \"cached\") {\n          record.doc = doc;\n          return _this.store.put(record, function() {\n            if (success != null) {\n              return success();\n            }\n          }, error);\n        } else {\n          if (success != null) {\n            return success();\n          }\n        }\n      };\n    })(this));\n  };\n\n  Collection.prototype.uncache = function(selector, success, error) {\n    var compiledSelector;\n    compiledSelector = utils.compileDocumentSelector(selector);\n    return this.store.query((function(_this) {\n      return function(matches) {\n        var keys;\n        matches = _.filter(matches, function(m) {\n          return m.state === \"cached\" && compiledSelector(m.doc);\n        });\n        keys = _.map(matches, function(m) {\n          return [_this.name, m.doc._id];\n        });\n        if (keys.length > 0) {\n          return _this.store.removeBatch(keys, function() {\n            if (success != null) {\n              return success();\n            }\n          }, error);\n        } else {\n          if (success != null) {\n            return success();\n          }\n        }\n      };\n    })(this), {\n      index: \"col\",\n      keyRange: this.store.makeKeyRange({\n        only: this.name\n      }),\n      onError: error\n    });\n  };\n\n  return Collection;\n\n})();\n","/home/travis/build/npmtest/node-npmtest-minimongo/node_modules/minimongo/lib/WebSQLDb.js":"var Collection, WebSQLDb, async, compileSort, doNothing, processFind, utils, _;\n\n_ = require('lodash');\n\nasync = require('async');\n\nutils = require('./utils');\n\nprocessFind = require('./utils').processFind;\n\ncompileSort = require('./selector').compileSort;\n\ndoNothing = function() {};\n\nmodule.exports = WebSQLDb = (function() {\n  function WebSQLDb(options, success, error) {\n    var checkV2, ex, migrateToV1, migrateToV2;\n    this.collections = {};\n    try {\n      this.db = window.openDatabase('minimongo_' + options.namespace, '', 'Minimongo:' + options.namespace, 5 * 1024 * 1024);\n      if (!this.db) {\n        return error(new Error(\"Failed to create database\"));\n      }\n    } catch (_error) {\n      ex = _error;\n      if (error) {\n        error(ex);\n      }\n      return;\n    }\n    migrateToV1 = function(tx) {\n      return tx.executeSql('CREATE TABLE docs (\\n  col TEXT NOT NULL,\\n  id TEXT NOT NULL,\\n  state TEXT NOT NULL,\\n  doc TEXT,\\n  PRIMARY KEY (col, id));', [], doNothing, (function(tx, err) {\n        return error(err);\n      }));\n    };\n    migrateToV2 = function(tx) {\n      return tx.executeSql('ALTER TABLE docs ADD COLUMN base TEXT;', [], doNothing, (function(tx, err) {\n        return error(err);\n      }));\n    };\n    checkV2 = (function(_this) {\n      return function() {\n        if (_this.db.version === \"1.0\") {\n          return _this.db.changeVersion(\"1.0\", \"2.0\", migrateToV2, error, function() {\n            if (success) {\n              return success(_this);\n            }\n          });\n        } else if (_this.db.version !== \"2.0\") {\n          return error(\"Unknown db version \" + _this.db.version);\n        } else {\n          if (success) {\n            return success(_this);\n          }\n        }\n      };\n    })(this);\n    if (!this.db.version) {\n      this.db.changeVersion(\"\", \"1.0\", migrateToV1, error, checkV2);\n    } else {\n      checkV2();\n    }\n    return this.db;\n  }\n\n  WebSQLDb.prototype.addCollection = function(name, success, error) {\n    var collection;\n    collection = new Collection(name, this.db);\n    this[name] = collection;\n    this.collections[name] = collection;\n    if (success) {\n      return success();\n    }\n  };\n\n  WebSQLDb.prototype.removeCollection = function(name, success, error) {\n    delete this[name];\n    delete this.collections[name];\n    return this.db.transaction(function(tx) {\n      return tx.executeSql(\"DELETE FROM docs WHERE col = ?\", [name], success, (function(tx, err) {\n        return error(err);\n      }));\n    }, error);\n  };\n\n  return WebSQLDb;\n\n})();\n\nCollection = (function() {\n  function Collection(name, db) {\n    this.name = name;\n    this.db = db;\n  }\n\n  Collection.prototype.find = function(selector, options) {\n    return {\n      fetch: (function(_this) {\n        return function(success, error) {\n          return _this._findFetch(selector, options, success, error);\n        };\n      })(this)\n    };\n  };\n\n  Collection.prototype.findOne = function(selector, options, success, error) {\n    var _ref;\n    if (_.isFunction(options)) {\n      _ref = [{}, options, success], options = _ref[0], success = _ref[1], error = _ref[2];\n    }\n    return this.find(selector, options).fetch(function(results) {\n      if (success != null) {\n        return success(results.length > 0 ? results[0] : null);\n      }\n    }, error);\n  };\n\n  Collection.prototype._findFetch = function(selector, options, success, error) {\n    error = error || function() {};\n    return this.db.readTransaction((function(_this) {\n      return function(tx) {\n        return tx.executeSql(\"SELECT * FROM docs WHERE col = ?\", [_this.name], function(tx, results) {\n          var docs, i, row, _i, _ref;\n          docs = [];\n          for (i = _i = 0, _ref = results.rows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n            row = results.rows.item(i);\n            if (row.state !== \"removed\") {\n              docs.push(JSON.parse(row.doc));\n            }\n          }\n          if (success != null) {\n            return success(processFind(docs, selector, options));\n          }\n        }, (function(tx, err) {\n          return error(err);\n        }));\n      };\n    })(this), error);\n  };\n\n  Collection.prototype.upsert = function(docs, bases, success, error) {\n    var items, _ref;\n    _ref = utils.regularizeUpsert(docs, bases, success, error), items = _ref[0], success = _ref[1], error = _ref[2];\n    error = error || function() {};\n    return this.db.transaction((function(_this) {\n      return function(tx) {\n        var ids;\n        ids = _.map(items, function(item) {\n          return item.doc._id;\n        });\n        bases = {};\n        return async.eachSeries(ids, function(id, callback) {\n          return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [_this.name, id], function(tx2, results) {\n            var row;\n            tx = tx2;\n            if (results.rows.length > 0) {\n              row = results.rows.item(0);\n              if (row.state === \"upserted\") {\n                bases[row.id] = row.base ? JSON.parse(row.base) : null;\n              } else if (row.state === \"cached\") {\n                bases[row.id] = JSON.parse(row.doc);\n              }\n            }\n            return callback();\n          }, (function(tx, err) {\n            return error(err);\n          }));\n        }, function() {\n          var base, id, item, _i, _len, _results;\n          _results = [];\n          for (_i = 0, _len = items.length; _i < _len; _i++) {\n            item = items[_i];\n            id = item.doc._id;\n            if (item.base !== void 0) {\n              base = item.base;\n            } else if (bases[id]) {\n              base = bases[id];\n            } else {\n              base = null;\n            }\n            _results.push(tx.executeSql(\"INSERT OR REPLACE INTO docs (col, id, state, doc, base) VALUES (?, ?, ?, ?, ?)\", [_this.name, item.doc._id, \"upserted\", JSON.stringify(item.doc), JSON.stringify(base)], doNothing, (function(tx, err) {\n              return error(err);\n            })));\n          }\n          return _results;\n        });\n      };\n    })(this), error, function() {\n      if (success) {\n        return success(docs);\n      }\n    });\n  };\n\n  Collection.prototype.remove = function(id, success, error) {\n    if (_.isObject(id)) {\n      this.find(id).fetch((function(_this) {\n        return function(rows) {\n          return async.each(rows, function(row, cb) {\n            return _this.remove(row._id, (function() {\n              return cb();\n            }), cb);\n          }, function() {\n            return success();\n          });\n        };\n      })(this), error);\n      return;\n    }\n    error = error || function() {};\n    return this.db.transaction((function(_this) {\n      return function(tx) {\n        return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [_this.name, id], function(tx, results) {\n          if (results.rows.length > 0) {\n            return tx.executeSql('UPDATE docs SET state=\"removed\" WHERE col = ? AND id = ?', [_this.name, id], function() {\n              if (success) {\n                return success(id);\n              }\n            }, (function(tx, err) {\n              return error(err);\n            }));\n          } else {\n            return tx.executeSql(\"INSERT INTO docs (col, id, state, doc) VALUES (?, ?, ?, ?)\", [\n              _this.name, id, \"removed\", JSON.stringify({\n                _id: id\n              })\n            ], function() {\n              if (success) {\n                return success(id);\n              }\n            }, (function(tx, err) {\n              return error(err);\n            }));\n          }\n        }, (function(tx, err) {\n          return error(err);\n        }));\n      };\n    })(this), error);\n  };\n\n  Collection.prototype.cache = function(docs, selector, options, success, error) {\n    error = error || function() {};\n    return this.db.transaction((function(_this) {\n      return function(tx) {\n        return async.eachSeries(docs, function(doc, callback) {\n          return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [_this.name, doc._id], function(tx, results) {\n            var existing;\n            if (results.rows.length === 0 || results.rows.item(0).state === \"cached\") {\n              existing = results.rows.length > 0 ? JSON.parse(results.rows.item(0).doc) : null;\n              if (!existing || !doc._rev || !existing._rev || doc._rev >= existing._rev) {\n                return tx.executeSql(\"INSERT OR REPLACE INTO docs (col, id, state, doc) VALUES (?, ?, ?, ?)\", [_this.name, doc._id, \"cached\", JSON.stringify(doc)], function() {\n                  return callback();\n                }, (function(tx, err) {\n                  return error(err);\n                }));\n              } else {\n                return callback();\n              }\n            } else {\n              return callback();\n            }\n          }, (function(tx, err) {\n            return error(err);\n          }));\n        }, function(err) {\n          var docsMap, sort;\n          if (err) {\n            if (error) {\n              error(err);\n            }\n            return;\n          }\n          docsMap = _.object(_.pluck(docs, \"_id\"), docs);\n          if (options.sort) {\n            sort = compileSort(options.sort);\n          }\n          return _this.find(selector, options).fetch(function(results) {\n            return _this.db.transaction(function(tx) {\n              return async.eachSeries(results, function(result, callback) {\n                return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [_this.name, result._id], function(tx, rows) {\n                  if (!docsMap[result._id] && rows.rows.length > 0 && rows.rows.item(0).state === \"cached\") {\n                    if (options.sort && options.limit && docs.length === options.limit) {\n                      if (sort(result, _.last(docs)) >= 0) {\n                        return callback();\n                      }\n                    }\n                    return tx.executeSql(\"DELETE FROM docs WHERE col = ? AND id = ?\", [_this.name, result._id], function() {\n                      return callback();\n                    }, (function(tx, err) {\n                      return error(err);\n                    }));\n                  } else {\n                    return callback();\n                  }\n                }, (function(tx, err) {\n                  return error(err);\n                }));\n              }, function(err) {\n                if (err != null) {\n                  if (error != null) {\n                    error(err);\n                  }\n                  return;\n                }\n                if (success != null) {\n                  return success();\n                }\n              });\n            }, error);\n          }, error);\n        });\n      };\n    })(this), error);\n  };\n\n  Collection.prototype.pendingUpserts = function(success, error) {\n    error = error || function() {};\n    return this.db.readTransaction((function(_this) {\n      return function(tx) {\n        return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND state = ?\", [_this.name, \"upserted\"], function(tx, results) {\n          var docs, i, row, _i, _ref;\n          docs = [];\n          for (i = _i = 0, _ref = results.rows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n            row = results.rows.item(i);\n            docs.push({\n              doc: JSON.parse(row.doc),\n              base: row.base ? JSON.parse(row.base) : null\n            });\n          }\n          if (success != null) {\n            return success(docs);\n          }\n        }, (function(tx, err) {\n          return error(err);\n        }));\n      };\n    })(this), error);\n  };\n\n  Collection.prototype.pendingRemoves = function(success, error) {\n    error = error || function() {};\n    return this.db.readTransaction((function(_this) {\n      return function(tx) {\n        return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND state = ?\", [_this.name, \"removed\"], function(tx, results) {\n          var docs, i, row, _i, _ref;\n          docs = [];\n          for (i = _i = 0, _ref = results.rows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n            row = results.rows.item(i);\n            docs.push(JSON.parse(row.doc)._id);\n          }\n          if (success != null) {\n            return success(docs);\n          }\n        }, (function(tx, err) {\n          return error(err);\n        }));\n      };\n    })(this), error);\n  };\n\n  Collection.prototype.resolveUpserts = function(upserts, success, error) {\n    error = error || function() {};\n    return this.db.transaction((function(_this) {\n      return function(tx) {\n        return async.eachSeries(upserts, function(upsert, cb) {\n          return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [_this.name, upsert.doc._id], function(tx, results) {\n            if (results.rows.length > 0 && results.rows.item(0).state === \"upserted\") {\n              if (_.isEqual(JSON.parse(results.rows.item(0).doc), upsert.doc)) {\n                tx.executeSql('UPDATE docs SET state=\"cached\" WHERE col = ? AND id = ?', [_this.name, upsert.doc._id], doNothing, (function(tx, err) {\n                  return error(err);\n                }));\n                return cb();\n              } else {\n                tx.executeSql('UPDATE docs SET base=? WHERE col = ? AND id = ?', [JSON.stringify(upsert.doc), _this.name, upsert.doc._id], doNothing, (function(tx, err) {\n                  return error(err);\n                }));\n                return cb();\n              }\n            } else {\n              return cb();\n            }\n          }, (function(tx, err) {\n            return error(err);\n          }));\n        }, function(err) {\n          if (err) {\n            return error(err);\n          }\n          if (success) {\n            return success();\n          }\n        });\n      };\n    })(this), error);\n  };\n\n  Collection.prototype.resolveRemove = function(id, success, error) {\n    error = error || function() {};\n    return this.db.transaction((function(_this) {\n      return function(tx) {\n        return tx.executeSql('DELETE FROM docs WHERE state=\"removed\" AND col = ? AND id = ?', [_this.name, id], function() {\n          if (success) {\n            return success(id);\n          }\n        }, (function(tx, err) {\n          return error(err);\n        }));\n      };\n    })(this), error);\n  };\n\n  Collection.prototype.seed = function(docs, success, error) {\n    if (!_.isArray(docs)) {\n      docs = [docs];\n    }\n    error = error || function() {};\n    return this.db.transaction((function(_this) {\n      return function(tx) {\n        return async.eachSeries(docs, function(doc, callback) {\n          return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [_this.name, doc._id], function(tx, results) {\n            if (results.rows.length === 0) {\n              return tx.executeSql(\"INSERT OR REPLACE INTO docs (col, id, state, doc) VALUES (?, ?, ?, ?)\", [_this.name, doc._id, \"cached\", JSON.stringify(doc)], function() {\n                return callback();\n              }, (function(tx, err) {\n                return error(err);\n              }));\n            } else {\n              return callback();\n            }\n          }, (function(tx, err) {\n            return error(err);\n          }));\n        }, function(err) {\n          if (err) {\n            if (error) {\n              return error(err);\n            }\n          } else {\n            if (success) {\n              return success();\n            }\n          }\n        });\n      };\n    })(this), error);\n  };\n\n  Collection.prototype.cacheOne = function(doc, success, error) {\n    error = error || function() {};\n    return this.db.transaction((function(_this) {\n      return function(tx) {\n        return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [_this.name, doc._id], function(tx, results) {\n          var existing;\n          if (results.rows.length === 0 || results.rows.item(0).state === \"cached\") {\n            existing = results.rows.length > 0 ? JSON.parse(results.rows.item(0).doc) : null;\n            if (!existing || !doc._rev || !existing._rev || doc._rev >= existing._rev) {\n              return tx.executeSql(\"INSERT OR REPLACE INTO docs (col, id, state, doc) VALUES (?, ?, ?, ?)\", [_this.name, doc._id, \"cached\", JSON.stringify(doc)], function() {\n                if (success) {\n                  return success(doc);\n                }\n              }, (function(tx, err) {\n                return error(err);\n              }));\n            } else {\n              if (success) {\n                return success(doc);\n              }\n            }\n          } else {\n            if (success) {\n              return success(doc);\n            }\n          }\n        }, (function(tx, err) {\n          return error(err);\n        }));\n      };\n    })(this), error);\n  };\n\n  Collection.prototype.uncache = function(selector, success, error) {\n    var compiledSelector;\n    compiledSelector = utils.compileDocumentSelector(selector);\n    error = error || function() {};\n    return this.db.transaction((function(_this) {\n      return function(tx) {\n        return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND state = ?\", [_this.name, \"cached\"], function(tx, results) {\n          var doc, i, row, toRemove, _i, _ref;\n          toRemove = [];\n          for (i = _i = 0, _ref = results.rows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n            row = results.rows.item(i);\n            doc = JSON.parse(row.doc);\n            if (compiledSelector(doc)) {\n              toRemove.push(doc._id);\n            }\n          }\n          return async.eachSeries(toRemove, function(id, callback) {\n            return tx.executeSql('DELETE FROM docs WHERE state=\"cached\" AND col = ? AND id = ?', [_this.name, id], function() {\n              return callback();\n            }, (function(tx, err) {\n              return error(err);\n            }));\n          }, function(err) {\n            if (err) {\n              if (error) {\n                return error(err);\n              }\n            } else {\n              if (success) {\n                return success();\n              }\n            }\n          });\n        }, (function(tx, err) {\n          return error(err);\n        }));\n      };\n    })(this), error);\n  };\n\n  return Collection;\n\n})();\n","/home/travis/build/npmtest/node-npmtest-minimongo/node_modules/minimongo/lib/RemoteDb.js":"var $, Collection, RemoteDb, async, jQueryHttpClient, utils, _;\n\n_ = require('lodash');\n\n$ = require('jquery');\n\nasync = require('async');\n\nutils = require('./utils');\n\njQueryHttpClient = require('./jQueryHttpClient');\n\nmodule.exports = RemoteDb = (function() {\n  function RemoteDb(url, client, httpClient) {\n    this.url = url;\n    this.client = client;\n    this.collections = {};\n    this.httpClient = httpClient || jQueryHttpClient;\n  }\n\n  RemoteDb.prototype.addCollection = function(name, options, success, error) {\n    var collection, url, _ref;\n    if (options == null) {\n      options = {};\n    }\n    if (_.isFunction(options)) {\n      _ref = [{}, options, success], options = _ref[0], success = _ref[1], error = _ref[2];\n    }\n    url = options.url || (this.url + name);\n    collection = new Collection(name, url, this.client, this.httpClient);\n    this[name] = collection;\n    this.collections[name] = collection;\n    if (success != null) {\n      return success();\n    }\n  };\n\n  RemoteDb.prototype.removeCollection = function(name, success, error) {\n    delete this[name];\n    delete this.collections[name];\n    if (success != null) {\n      return success();\n    }\n  };\n\n  return RemoteDb;\n\n})();\n\nCollection = (function() {\n  function Collection(name, url, client, httpClient) {\n    this.name = name;\n    this.url = url;\n    this.client = client;\n    this.httpClient = httpClient;\n  }\n\n  Collection.prototype.find = function(selector, options) {\n    if (options == null) {\n      options = {};\n    }\n    return {\n      fetch: (function(_this) {\n        return function(success, error) {\n          var params;\n          params = {};\n          if (options.sort) {\n            params.sort = JSON.stringify(options.sort);\n          }\n          if (options.limit) {\n            params.limit = options.limit;\n          }\n          if (options.skip) {\n            params.skip = options.skip;\n          }\n          if (options.fields) {\n            params.fields = JSON.stringify(options.fields);\n          }\n          if (_this.client) {\n            params.client = _this.client;\n          }\n          params.selector = JSON.stringify(selector || {});\n          if ((typeof navigator !== \"undefined\" && navigator !== null) && navigator.userAgent.toLowerCase().indexOf('android 2.3') !== -1) {\n            params._ = new Date().getTime();\n          }\n          return _this.httpClient(\"GET\", _this.url, params, null, success, error);\n        };\n      })(this)\n    };\n  };\n\n  Collection.prototype.findOne = function(selector, options, success, error) {\n    var params, _ref;\n    if (options == null) {\n      options = {};\n    }\n    if (_.isFunction(options)) {\n      _ref = [{}, options, success], options = _ref[0], success = _ref[1], error = _ref[2];\n    }\n    params = {};\n    if (options.sort) {\n      params.sort = JSON.stringify(options.sort);\n    }\n    params.limit = 1;\n    if (this.client) {\n      params.client = this.client;\n    }\n    params.selector = JSON.stringify(selector || {});\n    if ((typeof navigator !== \"undefined\" && navigator !== null) && navigator.userAgent.toLowerCase().indexOf('android 2.3') !== -1) {\n      params._ = new Date().getTime();\n    }\n    return this.httpClient(\"GET\", this.url, params, null, function(results) {\n      if (results && results.length > 0) {\n        return success(results[0]);\n      } else {\n        return success(null);\n      }\n    }, error);\n  };\n\n  Collection.prototype.upsert = function(docs, bases, success, error) {\n    var items, results, _ref;\n    _ref = utils.regularizeUpsert(docs, bases, success, error), items = _ref[0], success = _ref[1], error = _ref[2];\n    if (!this.client) {\n      throw new Error(\"Client required to upsert\");\n    }\n    results = [];\n    return async.eachLimit(items, 8, (function(_this) {\n      return function(item, cb) {\n        var params;\n        if (!item.doc._id) {\n          item.doc._id = utils.createUid();\n        }\n        params = {\n          client: _this.client\n        };\n        if ((typeof navigator !== \"undefined\" && navigator !== null) && navigator.userAgent.toLowerCase().indexOf('android 2.3') !== -1) {\n          params._ = new Date().getTime();\n        }\n        if (item.base) {\n          return _this.httpClient(\"PATCH\", _this.url + \"/\" + item.doc._id, params, item, function(result) {\n            results.push(result);\n            return cb();\n          }, function(err) {\n            return cb(err);\n          });\n        } else {\n          return _this.httpClient(\"POST\", _this.url, params, item.doc, function(result) {\n            results.push(result);\n            return cb();\n          }, function(err) {\n            return cb(err);\n          });\n        }\n      };\n    })(this), function(err) {\n      if (err) {\n        if (error) {\n          error(err);\n        }\n        return;\n      }\n      if (_.isArray(docs)) {\n        if (success) {\n          return success(results);\n        }\n      } else {\n        if (success) {\n          return success(results[0]);\n        }\n      }\n    });\n  };\n\n  Collection.prototype.remove = function(id, success, error) {\n    var params;\n    if (!this.client) {\n      throw new Error(\"Client required to remove\");\n    }\n    params = {\n      client: this.client\n    };\n    return this.httpClient(\"DELETE\", this.url + \"/\" + id, params, null, success, function(err) {\n      if (err.status === 410) {\n        return success();\n      } else {\n        return error(err);\n      }\n    });\n  };\n\n  return Collection;\n\n})();\n","/home/travis/build/npmtest/node-npmtest-minimongo/node_modules/minimongo/lib/jQueryHttpClient.js":"module.exports = function(method, url, params, data, success, error) {\n  var fullUrl, req;\n  fullUrl = url + \"?\" + $.param(params);\n  if (method === \"GET\") {\n    req = $.ajax(fullUrl, {\n      dataType: \"json\",\n      timeout: 180000\n    });\n  } else if (method === \"DELETE\") {\n    req = $.ajax(fullUrl, {\n      type: 'DELETE',\n      timeout: 60000\n    });\n  } else if (method === \"POST\" || method === \"PATCH\") {\n    req = $.ajax(fullUrl, {\n      data: JSON.stringify(data),\n      contentType: 'application/json',\n      timeout: 60000,\n      type: method\n    });\n  } else {\n    throw new Error(\"Unknown method \" + method);\n  }\n  req.done(function(response, textStatus, jqXHR) {\n    return success(response || null);\n  });\n  return req.fail(function(jqXHR, textStatus, errorThrown) {\n    if (error) {\n      return error(jqXHR);\n    }\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-minimongo/node_modules/minimongo/lib/HybridDb.js":"\n/*\n\nDatabase which caches locally in a localDb but pulls results\nultimately from a RemoteDb\n */\nvar HybridCollection, HybridDb, processFind, utils, _;\n\n_ = require('lodash');\n\nprocessFind = require('./utils').processFind;\n\nutils = require('./utils');\n\nmodule.exports = HybridDb = (function() {\n  function HybridDb(localDb, remoteDb) {\n    this.localDb = localDb;\n    this.remoteDb = remoteDb;\n    this.collections = {};\n  }\n\n  HybridDb.prototype.addCollection = function(name, options, success, error) {\n    var collection, _ref;\n    if (_.isFunction(options)) {\n      _ref = [{}, options, success], options = _ref[0], success = _ref[1], error = _ref[2];\n    }\n    collection = new HybridCollection(name, this.localDb[name], this.remoteDb[name], options);\n    this[name] = collection;\n    this.collections[name] = collection;\n    if (success != null) {\n      return success();\n    }\n  };\n\n  HybridDb.prototype.removeCollection = function(name, success, error) {\n    delete this[name];\n    delete this.collections[name];\n    if (success != null) {\n      return success();\n    }\n  };\n\n  HybridDb.prototype.upload = function(success, error) {\n    var cols, uploadCols;\n    cols = _.values(this.collections);\n    uploadCols = function(cols, success, error) {\n      var col;\n      col = _.first(cols);\n      if (col) {\n        return col.upload(function() {\n          return uploadCols(_.rest(cols), success, error);\n        }, function(err) {\n          return error(err);\n        });\n      } else {\n        return success();\n      }\n    };\n    return uploadCols(cols, success, error);\n  };\n\n  return HybridDb;\n\n})();\n\nHybridCollection = (function() {\n  function HybridCollection(name, localCol, remoteCol, options) {\n    this.name = name;\n    this.localCol = localCol;\n    this.remoteCol = remoteCol;\n    this.options = options || {};\n    _.defaults(this.options, {\n      cacheFind: true,\n      cacheFindOne: true,\n      interim: true,\n      useLocalOnRemoteError: true,\n      shortcut: false,\n      timeout: 0,\n      sortUpserts: null\n    });\n  }\n\n  HybridCollection.prototype.find = function(selector, options) {\n    if (options == null) {\n      options = {};\n    }\n    return {\n      fetch: (function(_this) {\n        return function(success, error) {\n          return _this._findFetch(selector, options, success, error);\n        };\n      })(this)\n    };\n  };\n\n  HybridCollection.prototype.findOne = function(selector, options, success, error) {\n    var step2, _ref;\n    if (options == null) {\n      options = {};\n    }\n    if (_.isFunction(options)) {\n      _ref = [{}, options, success], options = _ref[0], success = _ref[1], error = _ref[2];\n    }\n    _.defaults(options, this.options);\n    step2 = (function(_this) {\n      return function(localDoc) {\n        var findOptions;\n        findOptions = _.cloneDeep(options);\n        findOptions.interim = false;\n        findOptions.cacheFind = options.cacheFindOne;\n        if (selector._id) {\n          findOptions.limit = 1;\n        } else {\n          delete findOptions.limit;\n        }\n        return _this.find(selector, findOptions).fetch(function(data) {\n          if (data.length > 0) {\n            if (!_.isEqual(localDoc, data[0])) {\n              return success(data[0]);\n            }\n          } else {\n            return success(null);\n          }\n        }, error);\n      };\n    })(this);\n    if (options.interim || options.shortcut) {\n      return this.localCol.findOne(selector, options, function(localDoc) {\n        if (localDoc) {\n          success(_.cloneDeep(localDoc));\n          if (options.shortcut) {\n            return;\n          }\n        }\n        return step2(localDoc);\n      }, error);\n    } else {\n      return step2();\n    }\n  };\n\n  HybridCollection.prototype._findFetch = function(selector, options, success, error) {\n    var localSuccess, step2;\n    _.defaults(options, this.options);\n    step2 = (function(_this) {\n      return function(localData) {\n        var remoteError, remoteOptions, remoteSuccess, timedOut, timer;\n        remoteOptions = _.cloneDeep(options);\n        if (options.cacheFind) {\n          delete remoteOptions.fields;\n        }\n        timer = null;\n        timedOut = false;\n        remoteSuccess = function(remoteData) {\n          var cacheSuccess, data;\n          if (timer) {\n            clearTimeout(timer);\n          }\n          if (timedOut) {\n            if (options.cacheFind) {\n              _this.localCol.cache(remoteData, selector, options, (function() {}), error);\n            }\n            return;\n          }\n          if (options.cacheFind) {\n            cacheSuccess = function() {\n              var localSuccess2;\n              localSuccess2 = function(localData2) {\n                if (!_.isEqual(localData, localData2)) {\n                  return success(localData2);\n                }\n              };\n              return _this.localCol.find(selector, options).fetch(localSuccess2, error);\n            };\n            return _this.localCol.cache(remoteData, selector, options, cacheSuccess, error);\n          } else {\n            data = remoteData;\n            return _this.localCol.pendingRemoves(function(removes) {\n              var removesMap;\n              if (removes.length > 0) {\n                removesMap = _.object(_.map(removes, function(id) {\n                  return [id, id];\n                }));\n                data = _.filter(remoteData, function(doc) {\n                  return !_.has(removesMap, doc._id);\n                });\n              }\n              return _this.localCol.pendingUpserts(function(upserts) {\n                var upsertsMap;\n                if (upserts.length > 0) {\n                  upsertsMap = _.object(_.map(upserts, function(u) {\n                    return u.doc._id;\n                  }), _.map(upserts, function(u) {\n                    return u.doc._id;\n                  }));\n                  data = _.filter(data, function(doc) {\n                    return !_.has(upsertsMap, doc._id);\n                  });\n                  data = data.concat(_.pluck(upserts, \"doc\"));\n                  data = processFind(data, selector, options);\n                }\n                if (!_.isEqual(localData, data)) {\n                  return success(data);\n                }\n              }, error);\n            }, error);\n          }\n        };\n        remoteError = function(err) {\n          if (timer) {\n            clearTimeout(timer);\n          }\n          if (timedOut) {\n            return;\n          }\n          if (!options.interim) {\n            if (options.useLocalOnRemoteError) {\n              return _this.localCol.find(selector, options).fetch(success, error);\n            } else {\n              if (error) {\n                return error(err);\n              }\n            }\n          } else {\n\n          }\n        };\n        if (options.timeout) {\n          timer = setTimeout(function() {\n            timer = null;\n            timedOut = true;\n            if (!options.interim) {\n              if (options.useLocalOnRemoteError) {\n                return _this.localCol.find(selector, options).fetch(success, error);\n              } else {\n                if (error) {\n                  return error(new Error(\"Remote timed out\"));\n                }\n              }\n            } else {\n\n            }\n          }, options.timeout);\n        }\n        return _this.remoteCol.find(selector, remoteOptions).fetch(remoteSuccess, remoteError);\n      };\n    })(this);\n    if (options.interim) {\n      localSuccess = function(localData) {\n        success(localData);\n        return step2(localData);\n      };\n      return this.localCol.find(selector, options).fetch(localSuccess, error);\n    } else {\n      return step2();\n    }\n  };\n\n  HybridCollection.prototype.upsert = function(docs, bases, success, error) {\n    return this.localCol.upsert(docs, bases, function(result) {\n      if (_.isFunction(bases)) {\n        success = bases;\n      }\n      return typeof success === \"function\" ? success(docs) : void 0;\n    }, error);\n  };\n\n  HybridCollection.prototype.remove = function(id, success, error) {\n    return this.localCol.remove(id, function() {\n      if (success != null) {\n        return success();\n      }\n    }, error);\n  };\n\n  HybridCollection.prototype.upload = function(success, error) {\n    var uploadRemoves, uploadUpserts;\n    uploadUpserts = (function(_this) {\n      return function(upserts, success, error) {\n        var upsert;\n        upsert = _.first(upserts);\n        if (upsert) {\n          return _this.remoteCol.upsert(upsert.doc, upsert.base, function(remoteDoc) {\n            return _this.localCol.resolveUpserts([upsert], function() {\n              if (remoteDoc) {\n                return _this.localCol.cacheOne(remoteDoc, function() {\n                  return uploadUpserts(_.rest(upserts), success, error);\n                }, error);\n              } else {\n                return _this.localCol.remove(upsert.doc._id, function() {\n                  return _this.localCol.resolveRemove(upsert.doc._id, function() {\n                    return uploadUpserts(_.rest(upserts), success, error);\n                  }, error);\n                }, error);\n              }\n            }, error);\n          }, function(err) {\n            if (err.status === 410 || err.status === 403) {\n              return _this.localCol.remove(upsert.doc._id, function() {\n                return _this.localCol.resolveRemove(upsert.doc._id, function() {\n                  if (err.status === 410) {\n                    return uploadUpserts(_.rest(upserts), success, error);\n                  } else {\n                    return error(err);\n                  }\n                }, error);\n              }, error);\n            } else {\n              return error(err);\n            }\n          });\n        } else {\n          return success();\n        }\n      };\n    })(this);\n    uploadRemoves = (function(_this) {\n      return function(removes, success, error) {\n        var remove;\n        remove = _.first(removes);\n        if (remove) {\n          return _this.remoteCol.remove(remove, function() {\n            return _this.localCol.resolveRemove(remove, function() {\n              return uploadRemoves(_.rest(removes), success, error);\n            }, error);\n          }, function(err) {\n            if (err.status === 410 || err.status === 403) {\n              return _this.localCol.resolveRemove(remove, function() {\n                if (err.status === 410) {\n                  return uploadRemoves(_.rest(removes), success, error);\n                } else {\n                  return error(err);\n                }\n              }, error);\n            } else {\n              return error(err);\n            }\n          }, error);\n        } else {\n          return success();\n        }\n      };\n    })(this);\n    return this.localCol.pendingUpserts((function(_this) {\n      return function(upserts) {\n        if (_this.options.sortUpserts) {\n          upserts.sort(_this.options.sortUpserts);\n        }\n        return uploadUpserts(upserts, function() {\n          return _this.localCol.pendingRemoves(function(removes) {\n            return uploadRemoves(removes, success, error);\n          }, error);\n        }, error);\n      };\n    })(this), error);\n  };\n\n  return HybridCollection;\n\n})();\n","/home/travis/build/npmtest/node-npmtest-minimongo/node_modules/minimongo/lib/ReplicatingDb.js":"var Collection, ReplicatingDb, utils, _;\n\n_ = require('lodash');\n\nutils = require('./utils');\n\nmodule.exports = ReplicatingDb = (function() {\n  function ReplicatingDb(masterDb, replicaDb) {\n    this.collections = {};\n    this.masterDb = masterDb;\n    this.replicaDb = replicaDb;\n  }\n\n  ReplicatingDb.prototype.addCollection = function(name, success, error) {\n    var collection;\n    collection = new Collection(name, this.masterDb[name], this.replicaDb[name]);\n    this[name] = collection;\n    this.collections[name] = collection;\n    if (success != null) {\n      return success();\n    }\n  };\n\n  ReplicatingDb.prototype.removeCollection = function(name, success, error) {\n    delete this[name];\n    delete this.collections[name];\n    if (success != null) {\n      return success();\n    }\n  };\n\n  return ReplicatingDb;\n\n})();\n\nCollection = (function() {\n  function Collection(name, masterCol, replicaCol) {\n    this.name = name;\n    this.masterCol = masterCol;\n    this.replicaCol = replicaCol;\n  }\n\n  Collection.prototype.find = function(selector, options) {\n    return this.masterCol.find(selector, options);\n  };\n\n  Collection.prototype.findOne = function(selector, options, success, error) {\n    return this.masterCol.findOne(selector, options, success, error);\n  };\n\n  Collection.prototype.upsert = function(docs, bases, success, error) {\n    var items, _ref;\n    _ref = utils.regularizeUpsert(docs, bases, success, error), items = _ref[0], success = _ref[1], error = _ref[2];\n    return this.masterCol.upsert(_.pluck(items, \"doc\"), _.pluck(items, \"base\"), (function(_this) {\n      return function() {\n        return _this.replicaCol.upsert(_.pluck(items, \"doc\"), _.pluck(items, \"base\"), function(results) {\n          return success(docs);\n        }, error);\n      };\n    })(this), error);\n  };\n\n  Collection.prototype.remove = function(id, success, error) {\n    return this.masterCol.remove(id, (function(_this) {\n      return function() {\n        return _this.replicaCol.remove(id, success, error);\n      };\n    })(this), error);\n  };\n\n  Collection.prototype.cache = function(docs, selector, options, success, error) {\n    return this.masterCol.cache(docs, selector, options, (function(_this) {\n      return function() {\n        return _this.replicaCol.cache(docs, selector, options, success, error);\n      };\n    })(this), error);\n  };\n\n  Collection.prototype.pendingUpserts = function(success, error) {\n    return this.masterCol.pendingUpserts(success, error);\n  };\n\n  Collection.prototype.pendingRemoves = function(success, error) {\n    return this.masterCol.pendingRemoves(success, error);\n  };\n\n  Collection.prototype.resolveUpserts = function(upserts, success, error) {\n    return this.masterCol.resolveUpserts(upserts, (function(_this) {\n      return function() {\n        return _this.replicaCol.resolveUpserts(upserts, success, error);\n      };\n    })(this), error);\n  };\n\n  Collection.prototype.resolveRemove = function(id, success, error) {\n    return this.masterCol.resolveRemove(id, (function(_this) {\n      return function() {\n        return _this.replicaCol.resolveRemove(id, success, error);\n      };\n    })(this), error);\n  };\n\n  Collection.prototype.seed = function(docs, success, error) {\n    return this.masterCol.seed(docs, (function(_this) {\n      return function() {\n        return _this.replicaCol.seed(docs, success, error);\n      };\n    })(this), error);\n  };\n\n  Collection.prototype.cacheOne = function(doc, success, error) {\n    return this.masterCol.cacheOne(doc, (function(_this) {\n      return function() {\n        return _this.replicaCol.cacheOne(doc, success, error);\n      };\n    })(this), error);\n  };\n\n  Collection.prototype.uncache = function(selector, success, error) {\n    return this.masterCol.uncache(selector, (function(_this) {\n      return function() {\n        return _this.replicaCol.uncache(selector, success, error);\n      };\n    })(this), error);\n  };\n\n  return Collection;\n\n})();\n","/home/travis/build/npmtest/node-npmtest-minimongo/node_modules/minimongo/demo.js":"\nvar minimongo = require(\"minimongo\");\n\nvar LocalDb = minimongo.MemoryDb;\n\n// Create local db (in memory database with no backing)\ndb = new LocalDb();\n\n// Add a collection to the database\ndb.addCollection(\"animals\");\n\ndoc = { species: \"dog\", name: \"Bingo\" };\n\n// Always use upsert for both inserts and modifies\ndb.animals.upsert(doc, function() {\n\t// Success:\n\n\t// Query dog (with no query options beyond a selector)\n\tdb.animals.findOne({ species:\"dog\" }, {}, function(res) {\n\t\talert(\"Dog's name is: \" + res.name);\n\t});\n});\n","/home/travis/build/npmtest/node-npmtest-minimongo/node_modules/minimongo/gulpfile.js":"var gulp = require(\"gulp\");\nvar coffee = require('gulp-coffee');\nvar gutil = require('gulp-util');\nvar browserify = require('browserify');\nvar streamConvert = require('vinyl-source-stream');\nvar glob = require('glob');\nvar uglify = require('gulp-uglify');\nvar coffeeify = require('coffeeify');\nvar buffer = require('vinyl-buffer');\nvar rename = require(\"gulp-rename\");\n\n// Compilation\ngulp.task('coffee', function() {\n\treturn gulp.src('./src/*.coffee')\n\t\t.pipe(coffee({ bare: true }).on('error', gutil.log))\n\t\t.pipe(gulp.dest('./lib/'));\n});\n\ngulp.task('copy', function() {\n\treturn gulp.src(['./src/**/*.js'])\n\t\t.pipe(gulp.dest('./lib/'));\n});\n\ngulp.task('prepareTests', ['coffee', 'copy'], function() {\n\tvar bundler = browserify({entries: glob.sync(\"./test/*Tests.coffee\"), extensions: [\".coffee\"] }).\n\t\ttransform(coffeeify);\n\tvar stream = bundler.bundle()\n\t\t// TODO error handling not working\n\t    .on('error', gutil.log)\n\t    .on('error', function() { throw \"Failed\" })\n\t\t.pipe(streamConvert('browserified.js'))\n\t\t.pipe(gulp.dest('./test'));\n\treturn stream;\n});\n\ngulp.task('dist', ['copy', 'coffee'], function() {\n  bundler = browserify();\n  bundler.require(\"./jquery-shim.js\", { expose: \"jquery\"});\n  bundler.require(\"./lodash-shim.js\", { expose: \"lodash\"});\n  bundler.require(\"./index.js\", { expose: \"minimongo\"});\n  return bundler.bundle()\n    .pipe(streamConvert('minimongo.js'))\n    .pipe(gulp.dest(\"./dist/\"))\n    .pipe(buffer())\n    .pipe(rename(\"minimongo.min.js\"))\n    .pipe(uglify())\n    .pipe(gulp.dest('./dist/'));\n});\n\ngulp.task('default', ['coffee', 'copy', 'dist']);\n","/home/travis/build/npmtest/node-npmtest-minimongo/node_modules/minimongo/jquery-shim.js":"module.exports = window.$;\n","/home/travis/build/npmtest/node-npmtest-minimongo/node_modules/minimongo/lib/ReplicaDb.js":"var Collection, ReplicatingDb, _;\n\n_ = require('lodash');\n\nmodule.exports = ReplicatingDb = (function() {\n  function ReplicatingDb(masterDb, replicaDb) {\n    this.collections = {};\n    this.masterDb = masterDb;\n    this.replicaDb = replicaDb;\n  }\n\n  ReplicatingDb.prototype.addCollection = function(name, success, error) {\n    var collection;\n    collection = new Collection(name);\n    this[name] = collection;\n    this.collections[name] = collection;\n    if (success != null) {\n      return success();\n    }\n  };\n\n  ReplicatingDb.prototype.removeCollection = function(name, success, error) {\n    delete this[name];\n    delete this.collections[name];\n    if (success != null) {\n      return success();\n    }\n  };\n\n  return ReplicatingDb;\n\n})();\n\nCollection = (function() {\n  function Collection(name, masterCol, replicaCol) {\n    this.name = name;\n    this.masterCol = masterCol;\n    this.replicaCol = replicaCol;\n  }\n\n  Collection.prototype.find = function(selector, options) {\n    return {\n      fetch: (function(_this) {\n        return function(success, error) {\n          return _this._findFetch(selector, options, success, error);\n        };\n      })(this)\n    };\n  };\n\n  Collection.prototype.findOne = function(selector, options, success, error) {\n    var _ref;\n    if (_.isFunction(options)) {\n      _ref = [{}, options, success], options = _ref[0], success = _ref[1], error = _ref[2];\n    }\n    return this.find(selector, options).fetch(function(results) {\n      if (success != null) {\n        return success(results.length > 0 ? results[0] : null);\n      }\n    }, error);\n  };\n\n  Collection.prototype._findFetch = function(selector, options, success, error) {\n    return setTimeout((function(_this) {\n      return function() {\n        var results;\n        results = processFind(_.values(_this.items), selector, options);\n        if (success != null) {\n          return success(results);\n        }\n      };\n    })(this), 0);\n  };\n\n  Collection.prototype.upsert = function(docs, bases, success, error) {\n    var item, items, _i, _len, _ref;\n    _ref = utils.regularizeUpsert(docs, bases, success, error), items = _ref[0], success = _ref[1], error = _ref[2];\n    for (_i = 0, _len = items.length; _i < _len; _i++) {\n      item = items[_i];\n      if (item.base === void 0) {\n        if (this.upserts[item.doc._id]) {\n          item.base = this.upserts[item.doc._id].base;\n        } else {\n          item.base = this.items[item.doc._id] || null;\n        }\n      }\n      this.items[item.doc._id] = item.doc;\n      this.upserts[item.doc._id] = item;\n    }\n    if (success) {\n      return success(docs);\n    }\n  };\n\n  Collection.prototype.remove = function(id, success, error) {\n    if (_.has(this.items, id)) {\n      this.removes[id] = this.items[id];\n      delete this.items[id];\n      delete this.upserts[id];\n    } else {\n      this.removes[id] = {\n        _id: id\n      };\n    }\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype.cache = function(docs, selector, options, success, error) {\n    var doc, docsMap, sort, _i, _len;\n    for (_i = 0, _len = docs.length; _i < _len; _i++) {\n      doc = docs[_i];\n      this.cacheOne(doc);\n    }\n    docsMap = _.object(_.pluck(docs, \"_id\"), docs);\n    if (options.sort) {\n      sort = compileSort(options.sort);\n    }\n    return this.find(selector, options).fetch((function(_this) {\n      return function(results) {\n        var result, _j, _len1;\n        for (_j = 0, _len1 = results.length; _j < _len1; _j++) {\n          result = results[_j];\n          if (!docsMap[result._id] && !_.has(_this.upserts, result._id)) {\n            if (options.sort && options.limit && docs.length === options.limit) {\n              if (sort(result, _.last(docs)) >= 0) {\n                continue;\n              }\n            }\n            delete _this.items[result._id];\n          }\n        }\n        if (success != null) {\n          return success();\n        }\n      };\n    })(this), error);\n  };\n\n  Collection.prototype.pendingUpserts = function(success) {\n    return success(_.values(this.upserts));\n  };\n\n  Collection.prototype.pendingRemoves = function(success) {\n    return success(_.pluck(this.removes, \"_id\"));\n  };\n\n  Collection.prototype.resolveUpserts = function(upserts, success) {\n    var id, upsert, _i, _len;\n    for (_i = 0, _len = upserts.length; _i < _len; _i++) {\n      upsert = upserts[_i];\n      id = upsert.doc._id;\n      if (this.upserts[id]) {\n        if (_.isEqual(upsert.doc, this.upserts[id].doc)) {\n          delete this.upserts[id];\n        } else {\n          this.upserts[id].base = upsert.doc;\n        }\n      }\n    }\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype.resolveRemove = function(id, success) {\n    delete this.removes[id];\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype.seed = function(docs, success) {\n    var doc, _i, _len;\n    if (!_.isArray(docs)) {\n      docs = [docs];\n    }\n    for (_i = 0, _len = docs.length; _i < _len; _i++) {\n      doc = docs[_i];\n      if (!_.has(this.items, doc._id) && !_.has(this.removes, doc._id)) {\n        this.items[doc._id] = doc;\n      }\n    }\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype.cacheOne = function(doc, success) {\n    var existing;\n    if (!_.has(this.upserts, doc._id) && !_.has(this.removes, doc._id)) {\n      existing = this.items[doc._id];\n      if (!existing || !doc._rev || !existing._rev || doc._rev >= existing._rev) {\n        this.items[doc._id] = doc;\n      }\n    }\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype.uncache = function(selector, success, error) {\n    var compiledSelector, items;\n    compiledSelector = utils.compileDocumentSelector(selector);\n    items = _.filter(_.values(this.items), (function(_this) {\n      return function(item) {\n        return (_this.upserts[item._id] != null) || !compiledSelector(item);\n      };\n    })(this));\n    this.items = _.object(_.pluck(items, \"_id\"), items);\n    if (success != null) {\n      return success();\n    }\n  };\n\n  return Collection;\n\n})();\n","/home/travis/build/npmtest/node-npmtest-minimongo/node_modules/minimongo/lodash-shim.js":"module.exports = window._;\n"}